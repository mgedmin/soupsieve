{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Soup Sieve \ue157 Overview \ue157 Soup Sieve is a CSS selector library designed to be used with Beautiful Soup 4 . It aims to provide selecting, matching, and filtering using modern CSS selectors. Soup Sieve currently provides selectors from the CSS level 1 specifications up through the latest CSS level 4 drafts (though some are not yet implemented). Soup Sieve was written with the intent to replace Beautiful Soup's builtin select feature, and as of Beautiful Soup version 4.7.0, it now is . Soup Sieve can also be imported in order to use its API directly for more controlled, specialized parsing. Soup Sieve has implemented most of the CSS selectors up through the level 4 drafts, though there are a number that don't make sense in a non-browser environment. Selectors that cannot provide meaningful functionality simply do not match anything. Some of the supported selectors are: . classes # ids [ attributes = value ] parent child parent > child sibling ~ sibling sibling + sibling : not ( element . class , element2 . class ) : is ( element . class , element2 . class ) parent : has (> child ) and many more Installation \ue157 You must have Beautiful Soup already installed: pip install beautifulsoup4 In most cases, assuming you've installed version 4.7.0, that should be all you need to do, but if you've installed via some alternative method, and Soup Sieve is not automatically installed for your, you can install it directly: pip install soupsieve If you want to manually install it from source, navigate to the root of the project and run python setup.py build python setup.py install Usage \ue157 To use Soup Sieve, you must create a BeautifulSoup object: >>> import bs4 >>> text = \"\"\" ... <div> ... <!-- These are animals --> ... <p class=\"a\">Cat</p> ... <p class=\"b\">Dog</p> ... <p class=\"c\">Mouse</p> ... </div> ... \"\"\" >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) For most people, using the Beautiful Soup 4.7.0+ API may be more than sufficient. Beautiful Soup offers two methods that employ Soup Sieve: select and select_one . Beautiful Soup's select API is identical to Soup Sieve's, except that you don't have to hand it the tag object, the calling object passes itself to Soup Sieve: >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) >>> soup . select_one ( 'p:is(.a, .b, .c)' ) <p class=\"a\">Cat</p> >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) >>> soup . select ( 'p:is(.a, .b, .c)' ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can also use the Soup Sieve API directly to get access to the full range of possibilities that Soup Sieve offers. You can select a single tag: >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p> You can select all tags: >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can select the closest ancestor: >>> import soupsieve as sv >>> el = sv . select_one ( '.c' , soup ) >>> sv . closest ( 'div' , el ) <div> <!-- These are animals --> <p class=\"a\">Cat</p> <p class=\"b\">Dog</p> <p class=\"c\">Mouse</p> </div> You can filter a tag's Children (or an iterable of tags): >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>] You can match a single tag: >>> els = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( els [ 0 ], 'p:not(.b)' ) True >>> sv . match ( els [ 1 ], 'p:not(.b)' ) False Or even just extract comments: >>> sv . comments ( soup ) [' These are animals '] Selectors do not have to be constrained to one line either. You can span selectors over multiple lines just like you would in a CSS file. >>> selector = \"\"\" ... .a, ... .b, ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can even use comments to annotate a particularly complex selector. >>> selector = \"\"\" ... /* This isn't complicated, but we're going to annotate it anyways. ... This is the a class */ ... .a, ... /* This is the b class */ ... .b, ... /* This is the c class */ ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] If you've ever used Python's Re library for regular expressions, you may know that it is often useful to pre-compile a regular expression pattern, especially if you plan to use it more than once. The same is true for Soup Sieve's matchers, though is not required. If you have a pattern that you want to use more than once, it may be wise to pre-compile it early on: >>> selector = sv . compile ( 'p:is(.a, .b, .c)' ) >>> selector . filter ( soup . div ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] A compiled object has all the same methods, though the parameters will be slightly different as they don't need things like the pattern or flags once compiled. See API documentation for more info. Compiled patterns are cached, so if for any reason you need to clear the cache, simply issue the purge command. >>> sv . purge () Beautiful Soup Differences \ue157 Soup Sieve is the official CSS \"select\" implementation of Beautiful Soup 4.7.0+. While the inclusion of Soup Sieve fixes many issues and greatly expands CSS support in Beautiful Soup, it does introduce some differences which may surprise some who've become accustom to the old \"select\" implementation. Beautiful Soup's old select method had numerous limitations and quirks that do not align with the actual CSS specification. Most are insignificant, but there are a couple differences that people over the years had come to rely on. Soup Sieve, which aims to follow the CSS specification closely, does not support these differences. Beautiful Soup was very relaxed when it came to attribute values in selectors: [ attribute = value ] . Beautiful Soup would allow almost anything for a valid unquoted value. Soup Sieve, on the other hand, follows the CSS specification and requires that a value be a valid identifier, or it must be quoted. If you get an error complaining about an invalid attribute, you may need to quote the value. For instance, if you previously used a selector like this: soup . select ( '[div= {} ]' ) You would need to quote the value as {} is not a valid CSS identifier, so it must be quoted: soup . select ( '[div=\" {} \"]' ) Whether on purpose or on accident, Beautiful Soup used to allow relative selectors: soup . select ( '> div' ) The above is not a valid CSS selector according the CSS specifications. Relative selector lists have only recently been added to the CSS specifications, and they are only allowed in a : has () pseudo-class: article : has (> div ) But, in the level 4 CSS specifications, the :scope pseudo-class has been added which allows for the same feel as using > div . Since Soup Sieve supports the :scope pseudo-class, it can be used to produce the same behavior as the legacy select method. So, if you used to to have selectors such as: soup . select ( '> div' ) You can simply add :scope , and it should work the same: soup . select ( ':scope > div' )","title":"Soup Sieve"},{"location":"#soup-sieve","text":"","title":"Soup Sieve"},{"location":"#overview","text":"Soup Sieve is a CSS selector library designed to be used with Beautiful Soup 4 . It aims to provide selecting, matching, and filtering using modern CSS selectors. Soup Sieve currently provides selectors from the CSS level 1 specifications up through the latest CSS level 4 drafts (though some are not yet implemented). Soup Sieve was written with the intent to replace Beautiful Soup's builtin select feature, and as of Beautiful Soup version 4.7.0, it now is . Soup Sieve can also be imported in order to use its API directly for more controlled, specialized parsing. Soup Sieve has implemented most of the CSS selectors up through the level 4 drafts, though there are a number that don't make sense in a non-browser environment. Selectors that cannot provide meaningful functionality simply do not match anything. Some of the supported selectors are: . classes # ids [ attributes = value ] parent child parent > child sibling ~ sibling sibling + sibling : not ( element . class , element2 . class ) : is ( element . class , element2 . class ) parent : has (> child ) and many more","title":"Overview"},{"location":"#installation","text":"You must have Beautiful Soup already installed: pip install beautifulsoup4 In most cases, assuming you've installed version 4.7.0, that should be all you need to do, but if you've installed via some alternative method, and Soup Sieve is not automatically installed for your, you can install it directly: pip install soupsieve If you want to manually install it from source, navigate to the root of the project and run python setup.py build python setup.py install","title":"Installation"},{"location":"#usage","text":"To use Soup Sieve, you must create a BeautifulSoup object: >>> import bs4 >>> text = \"\"\" ... <div> ... <!-- These are animals --> ... <p class=\"a\">Cat</p> ... <p class=\"b\">Dog</p> ... <p class=\"c\">Mouse</p> ... </div> ... \"\"\" >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) For most people, using the Beautiful Soup 4.7.0+ API may be more than sufficient. Beautiful Soup offers two methods that employ Soup Sieve: select and select_one . Beautiful Soup's select API is identical to Soup Sieve's, except that you don't have to hand it the tag object, the calling object passes itself to Soup Sieve: >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) >>> soup . select_one ( 'p:is(.a, .b, .c)' ) <p class=\"a\">Cat</p> >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) >>> soup . select ( 'p:is(.a, .b, .c)' ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can also use the Soup Sieve API directly to get access to the full range of possibilities that Soup Sieve offers. You can select a single tag: >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p> You can select all tags: >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can select the closest ancestor: >>> import soupsieve as sv >>> el = sv . select_one ( '.c' , soup ) >>> sv . closest ( 'div' , el ) <div> <!-- These are animals --> <p class=\"a\">Cat</p> <p class=\"b\">Dog</p> <p class=\"c\">Mouse</p> </div> You can filter a tag's Children (or an iterable of tags): >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>] You can match a single tag: >>> els = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( els [ 0 ], 'p:not(.b)' ) True >>> sv . match ( els [ 1 ], 'p:not(.b)' ) False Or even just extract comments: >>> sv . comments ( soup ) [' These are animals '] Selectors do not have to be constrained to one line either. You can span selectors over multiple lines just like you would in a CSS file. >>> selector = \"\"\" ... .a, ... .b, ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can even use comments to annotate a particularly complex selector. >>> selector = \"\"\" ... /* This isn't complicated, but we're going to annotate it anyways. ... This is the a class */ ... .a, ... /* This is the b class */ ... .b, ... /* This is the c class */ ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] If you've ever used Python's Re library for regular expressions, you may know that it is often useful to pre-compile a regular expression pattern, especially if you plan to use it more than once. The same is true for Soup Sieve's matchers, though is not required. If you have a pattern that you want to use more than once, it may be wise to pre-compile it early on: >>> selector = sv . compile ( 'p:is(.a, .b, .c)' ) >>> selector . filter ( soup . div ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] A compiled object has all the same methods, though the parameters will be slightly different as they don't need things like the pattern or flags once compiled. See API documentation for more info. Compiled patterns are cached, so if for any reason you need to clear the cache, simply issue the purge command. >>> sv . purge ()","title":"Usage"},{"location":"#beautiful-soup-differences","text":"Soup Sieve is the official CSS \"select\" implementation of Beautiful Soup 4.7.0+. While the inclusion of Soup Sieve fixes many issues and greatly expands CSS support in Beautiful Soup, it does introduce some differences which may surprise some who've become accustom to the old \"select\" implementation. Beautiful Soup's old select method had numerous limitations and quirks that do not align with the actual CSS specification. Most are insignificant, but there are a couple differences that people over the years had come to rely on. Soup Sieve, which aims to follow the CSS specification closely, does not support these differences. Beautiful Soup was very relaxed when it came to attribute values in selectors: [ attribute = value ] . Beautiful Soup would allow almost anything for a valid unquoted value. Soup Sieve, on the other hand, follows the CSS specification and requires that a value be a valid identifier, or it must be quoted. If you get an error complaining about an invalid attribute, you may need to quote the value. For instance, if you previously used a selector like this: soup . select ( '[div= {} ]' ) You would need to quote the value as {} is not a valid CSS identifier, so it must be quoted: soup . select ( '[div=\" {} \"]' ) Whether on purpose or on accident, Beautiful Soup used to allow relative selectors: soup . select ( '> div' ) The above is not a valid CSS selector according the CSS specifications. Relative selector lists have only recently been added to the CSS specifications, and they are only allowed in a : has () pseudo-class: article : has (> div ) But, in the level 4 CSS specifications, the :scope pseudo-class has been added which allows for the same feel as using > div . Since Soup Sieve supports the :scope pseudo-class, it can be used to produce the same behavior as the legacy select method. So, if you used to to have selectors such as: soup . select ( '> div' ) You can simply add :scope , and it should work the same: soup . select ( ':scope > div' )","title":"Beautiful Soup Differences"},{"location":"api/","text":"API \ue157 Soup Sieve uses a subset of the CSS4 selector specification to detect and filter elements. To learn more about which specific selectors are implemented, see CSS Selectors . Soup Sieve will detect the document type being used from the Beautiful Soup object that is given to it, and depending on the document type, its behavior may be slightly different. When detecting XHTML, Soup Sieve simply looks to see if the root element of an XML document is under the XHTML namespace and does not currently look at the doctype . If in the future there is a need for stricter XHTML detection, this may change. HTML document types (HTML, HTML5) will have their tag names and attribute names treated without case sensitivity, like most browsers do. XML document types (including XHTML) will have their tag names and attribute names treated with case sensitivity. HTML5, XHTML and XML documents will have namespaces evaluated per the document's support (provided via the parser). Some additional configuration is required when using namespaces, see Namespace for more information. Getting Proper Namespaces The html5lib parser provides proper namespaces for HTML5, but lxml 's HTML parser will not. If you need namespace support for HTML5, consider using html5lib . For XML, the lxml-xml parser ( xml for short) will provide proper namespaces. It is generally suggested that lxml-xml is used to parse XHTML documents to take advantage of namespaces. While attribute values are generally treated as case sensitive, HTML5 and HTML treat the type attribute special. The type attribute's value is always case insensitive. This is generally how most browsers treat type . If you need type to be sensitive, you can use the s flag: [ type = \"submit\" s ] . As far as the API is concerned, Soup Sieve mimics Beautiful Soup's original API at the time of writing this, which is why the names select and select_one are used. As of today, Beautiful Soup has agreed to include Soup Sieve as the official select library which is slated for the 4.7.0 release. Soup Sieve will always be available as an external API as well for more controlled tag selection if needed. Flags \ue157 Early in development, flags were used to specify document type, but as of 1.0.0, there are no flags used at this time, but the parameter is provided for potential future use. soupsieve.select_one() \ue157 def select ( select , tag , namespaces = None , flags = 0 ): \"\"\"Select the specified tags.\"\"\" select_one will return the first tag under the given tag that matches the given CSS selectors provided, or it will return None if a suitable tag was not found. select_one accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags . >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p> soupsieve.select() \ue157 def select ( select , tag , namespaces = None , limit = 0 , flags = 0 ): \"\"\"Select the specified tags.\"\"\" select will return all tags under the given tag that match the given CSS selectors provided. You can also limit the number of tags returned by providing a positive integer via the limit parameter (0 means to return all tags). select accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, a limit , and flags . >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] soupsieve.iselect() \ue157 def iselect ( select , node , namespaces = None , limit = 0 , flags = 0 ): \"\"\"Select the specified tags.\"\"\" iselect is exactly like select except that it returns a generator instead of a list. soupsieve.closest() \ue157 def closest ( select , tag , namespaces = None , flags = 0 ): \"\"\"Match closest ancestor to the provided tag.\"\"\" closest returns the tag closest to the given tag that matches the given selector. The element found must be a direct ancestor of the tag or the tag itself. closest accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags . soupsieve.match() \ue157 def match ( select , tag , namespaces = None , flags = 0 ): \"\"\"Match node.\"\"\" The match function matches a given tag with a given CSS selector. match accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags. >>> nodes = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( 'p:not(.b)' , nodes [ 0 ]) True >>> sv . match ( 'p:not(.b)' , nodes [ 1 ]) False soupsieve.filter() \ue157 def filter ( select , nodes , namespaces = None , flags = 0 ): \"\"\"Filter list of nodes.\"\"\" filter takes an iterable containing HTML nodes and will filter them based on the provided CSS selector string. If given a Tag / BeautifulSoup object, it will iterate the direct children filtering them. filter accepts a CSS selector string, an iterable containing nodes, an optional namespace dictionary, and flags. >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>] soupsieve.comments() \ue157 def comments(tag, limit=0, flags=0): \"\"\"Get comments only.\"\"\" The comments function can be used to extract all comments from a document or document tag. It will return comments from the given tag down through all of its children. You can limit how many comments are returned with limit . comments accepts a Tag / BeautifulSoup object, a limit , and flags. soupsieve.icomments() \ue157 def icomments(node, limit=0, flags=0): \"\"\"Get comments only.\"\"\" icomments is exactly like comments except that it returns a generator instead of a list. soupsieve.compile() \ue157 def compile ( pattern , namespaces = None , flags = 0 ): \"\"\"Compile CSS pattern.\"\"\" compile will pre-compile a CSS selector pattern returning a SoupSieve object. The SoupSieve object has the same selector functions available via the module without the need to specify the selector, namespaces, or flags. class SoupSieve : \"\"\"Match tags in Beautiful Soup with CSS selectors.\"\"\" def match ( self , tag ): \"\"\"Match.\"\"\" def closest ( self , tag ): \"\"\"Match closest ancestor.\"\"\" def filter ( self , iterable ): \"\"\"Filter.\"\"\" def comments ( self , tag , limit = 0 ): \"\"\"Get comments only.\"\"\" def icomments ( self , tag , limit = 0 ): \"\"\"Iterate comments only.\"\"\" def select_one ( self , tag ): \"\"\"Select a single tag.\"\"\" def select ( self , tag , limit = 0 ): \"\"\"Select the specified tags.\"\"\" def iselect ( self , tag , limit = 0 ): \"\"\"Iterate the specified tags.\"\"\" soupsieve.purge() \ue157 Soup Sieve caches compiled patterns for performance. If for whatever reason, you need to purge the cache, simply call purge . Namespaces \ue157 Many of Soup Sieve's selector functions take an optional namespace dictionary. Namespaces, just like CSS, must be defined for Soup Sieve to evaluate ns|tag type selectors. This is analogous to CSS's namespace at-rule: @ namespace url ( \"http://www.w3.org/1999/xhtml\" ) ; @ namespace svg url ( \"http://www.w3.org/2000/svg\" ) ; A namespace dictionary should have keys (prefixes) and values (namespaces). An empty key string for a key would denote the default key. An empty value would essentially represent a null namespace. To represent the above CSS example for Soup Sieve, we would configure it like so: namespace = { \"\" : \"http://www.w3.org/1999/xhtml\" , # Default namespace is for XHTML \"svg\" : \"http://www.w3.org/2000/svg\" , # The SVG namespace defined with prefix of \"svg\" } Prefixes used in the namespace dictionary do not have to match the prefixes in the document. The provided prefix is never compared against the prefixes in the document, only the namespaces are compared. The prefixes in the document are only there for the parser to know which tags get which namespace. And the prefixes in the namespace dictionary are only defined in order to provide an alias for the namespaces when using the namespace selector syntax: ns|name . Tags do not necessarily have to have a prefix for Soup Sieve to recognize them either. For instance, in HTML5, SVG should automatically get the SVG namespace. Depending how namespaces were defined in the document, tags may inherit namespaces in some conditions. Namespace assignment is mainly handled by the parser and exposed through the Beautiful Soup API. Soup Sieve uses the Beautiful Soup API to then compare namespaces for supported documents.","title":"API"},{"location":"api/#api","text":"Soup Sieve uses a subset of the CSS4 selector specification to detect and filter elements. To learn more about which specific selectors are implemented, see CSS Selectors . Soup Sieve will detect the document type being used from the Beautiful Soup object that is given to it, and depending on the document type, its behavior may be slightly different. When detecting XHTML, Soup Sieve simply looks to see if the root element of an XML document is under the XHTML namespace and does not currently look at the doctype . If in the future there is a need for stricter XHTML detection, this may change. HTML document types (HTML, HTML5) will have their tag names and attribute names treated without case sensitivity, like most browsers do. XML document types (including XHTML) will have their tag names and attribute names treated with case sensitivity. HTML5, XHTML and XML documents will have namespaces evaluated per the document's support (provided via the parser). Some additional configuration is required when using namespaces, see Namespace for more information. Getting Proper Namespaces The html5lib parser provides proper namespaces for HTML5, but lxml 's HTML parser will not. If you need namespace support for HTML5, consider using html5lib . For XML, the lxml-xml parser ( xml for short) will provide proper namespaces. It is generally suggested that lxml-xml is used to parse XHTML documents to take advantage of namespaces. While attribute values are generally treated as case sensitive, HTML5 and HTML treat the type attribute special. The type attribute's value is always case insensitive. This is generally how most browsers treat type . If you need type to be sensitive, you can use the s flag: [ type = \"submit\" s ] . As far as the API is concerned, Soup Sieve mimics Beautiful Soup's original API at the time of writing this, which is why the names select and select_one are used. As of today, Beautiful Soup has agreed to include Soup Sieve as the official select library which is slated for the 4.7.0 release. Soup Sieve will always be available as an external API as well for more controlled tag selection if needed.","title":"API"},{"location":"api/#flags","text":"Early in development, flags were used to specify document type, but as of 1.0.0, there are no flags used at this time, but the parameter is provided for potential future use.","title":"Flags"},{"location":"api/#soupsieveselect_one","text":"def select ( select , tag , namespaces = None , flags = 0 ): \"\"\"Select the specified tags.\"\"\" select_one will return the first tag under the given tag that matches the given CSS selectors provided, or it will return None if a suitable tag was not found. select_one accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags . >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p>","title":"soupsieve.select_one()"},{"location":"api/#soupsieveselect","text":"def select ( select , tag , namespaces = None , limit = 0 , flags = 0 ): \"\"\"Select the specified tags.\"\"\" select will return all tags under the given tag that match the given CSS selectors provided. You can also limit the number of tags returned by providing a positive integer via the limit parameter (0 means to return all tags). select accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, a limit , and flags . >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>]","title":"soupsieve.select()"},{"location":"api/#soupsieveiselect","text":"def iselect ( select , node , namespaces = None , limit = 0 , flags = 0 ): \"\"\"Select the specified tags.\"\"\" iselect is exactly like select except that it returns a generator instead of a list.","title":"soupsieve.iselect()"},{"location":"api/#soupsieveclosest","text":"def closest ( select , tag , namespaces = None , flags = 0 ): \"\"\"Match closest ancestor to the provided tag.\"\"\" closest returns the tag closest to the given tag that matches the given selector. The element found must be a direct ancestor of the tag or the tag itself. closest accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags .","title":"soupsieve.closest()"},{"location":"api/#soupsievematch","text":"def match ( select , tag , namespaces = None , flags = 0 ): \"\"\"Match node.\"\"\" The match function matches a given tag with a given CSS selector. match accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags. >>> nodes = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( 'p:not(.b)' , nodes [ 0 ]) True >>> sv . match ( 'p:not(.b)' , nodes [ 1 ]) False","title":"soupsieve.match()"},{"location":"api/#soupsievefilter","text":"def filter ( select , nodes , namespaces = None , flags = 0 ): \"\"\"Filter list of nodes.\"\"\" filter takes an iterable containing HTML nodes and will filter them based on the provided CSS selector string. If given a Tag / BeautifulSoup object, it will iterate the direct children filtering them. filter accepts a CSS selector string, an iterable containing nodes, an optional namespace dictionary, and flags. >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>]","title":"soupsieve.filter()"},{"location":"api/#soupsievecomments","text":"def comments(tag, limit=0, flags=0): \"\"\"Get comments only.\"\"\" The comments function can be used to extract all comments from a document or document tag. It will return comments from the given tag down through all of its children. You can limit how many comments are returned with limit . comments accepts a Tag / BeautifulSoup object, a limit , and flags.","title":"soupsieve.comments()"},{"location":"api/#soupsieveicomments","text":"def icomments(node, limit=0, flags=0): \"\"\"Get comments only.\"\"\" icomments is exactly like comments except that it returns a generator instead of a list.","title":"soupsieve.icomments()"},{"location":"api/#soupsievecompile","text":"def compile ( pattern , namespaces = None , flags = 0 ): \"\"\"Compile CSS pattern.\"\"\" compile will pre-compile a CSS selector pattern returning a SoupSieve object. The SoupSieve object has the same selector functions available via the module without the need to specify the selector, namespaces, or flags. class SoupSieve : \"\"\"Match tags in Beautiful Soup with CSS selectors.\"\"\" def match ( self , tag ): \"\"\"Match.\"\"\" def closest ( self , tag ): \"\"\"Match closest ancestor.\"\"\" def filter ( self , iterable ): \"\"\"Filter.\"\"\" def comments ( self , tag , limit = 0 ): \"\"\"Get comments only.\"\"\" def icomments ( self , tag , limit = 0 ): \"\"\"Iterate comments only.\"\"\" def select_one ( self , tag ): \"\"\"Select a single tag.\"\"\" def select ( self , tag , limit = 0 ): \"\"\"Select the specified tags.\"\"\" def iselect ( self , tag , limit = 0 ): \"\"\"Iterate the specified tags.\"\"\"","title":"soupsieve.compile()"},{"location":"api/#soupsievepurge","text":"Soup Sieve caches compiled patterns for performance. If for whatever reason, you need to purge the cache, simply call purge .","title":"soupsieve.purge()"},{"location":"api/#namespaces","text":"Many of Soup Sieve's selector functions take an optional namespace dictionary. Namespaces, just like CSS, must be defined for Soup Sieve to evaluate ns|tag type selectors. This is analogous to CSS's namespace at-rule: @ namespace url ( \"http://www.w3.org/1999/xhtml\" ) ; @ namespace svg url ( \"http://www.w3.org/2000/svg\" ) ; A namespace dictionary should have keys (prefixes) and values (namespaces). An empty key string for a key would denote the default key. An empty value would essentially represent a null namespace. To represent the above CSS example for Soup Sieve, we would configure it like so: namespace = { \"\" : \"http://www.w3.org/1999/xhtml\" , # Default namespace is for XHTML \"svg\" : \"http://www.w3.org/2000/svg\" , # The SVG namespace defined with prefix of \"svg\" } Prefixes used in the namespace dictionary do not have to match the prefixes in the document. The provided prefix is never compared against the prefixes in the document, only the namespaces are compared. The prefixes in the document are only there for the parser to know which tags get which namespace. And the prefixes in the namespace dictionary are only defined in order to provide an alias for the namespaces when using the namespace selector syntax: ns|name . Tags do not necessarily have to have a prefix for Soup Sieve to recognize them either. For instance, in HTML5, SVG should automatically get the SVG namespace. Depending how namespaces were defined in the document, tags may inherit namespaces in some conditions. Namespace assignment is mainly handled by the parser and exposed through the Beautiful Soup API. Soup Sieve uses the Beautiful Soup API to then compare namespaces for supported documents.","title":"Namespaces"},{"location":"selectors/","text":"CSS Selectors \ue157 The CSS selectors are based off of the CSS level 4 specification. Primarily support has been added for selectors that were feasible to implement and most likely to get practical use. When speaking about namespaces, they only apply to XML, XHTML, or when dealing with recognized foreign tags in HTML5. Currently, Beautiful Soup's html5lib parser is the only parser that will return the appropriate namespaces for a HTML5 document. If you are using XHTML, you have to use the Beautiful Soup's lxml-xml parser (or xml for short) to get the appropriate namespaces in an XHTML document. In addition to using the correct parser, you must provide a dictionary of namespaces to Soup Sieve in order to use namespace selectors. See the documentation on namespaces to learn more. While an effort is made to mimic CSS selector behavior, there may be some differences or quirks, please report issues if any are found. Symbol Description Some selectors are dependent upon certain states in a web browser or other context which is simply not present outside a web browser. An example would be the :focus selector. In Soup Sieve, :focus will match nothing because elements cannot be focused outside of a browser without simulation, or somehow connecting to a browser. These types of selectors, that provide no meaningful information in Soup Sieve, will be marked with . Some selectors are very specific to HTML and either have no meaningful representation in XML, or such functionality has not been implemented. Selectors that are HTML only will be noted with , and will match nothing if used in XML. Soup Sieve has implemented a couple non-standard selectors. These can contain useful selectors that were rejected from the official CSS specifications, selectors implemented by other systems such as JQuery, or even selectors specifically created for Soup Sieve. If a selector is considered non standard, it will be marked with . All selectors that are from the current working draft of CSS4 are considered experimental and are marked with . Additionally, if there are other immature selectors, they may be marked as experimental as well. Experimental may mean we are not entirely sure if our implementation is correct, that things may still be in flux as they are part of a working draft, or even both. Additional Reading If usage of a selector is not clear in this documentation, you can find more information by reading these specification documents: CSS Level 3 Specification Contains the latest official document outlying official behaviors of CSS selectors. CSS Level 4 Working Draft Contains the latest published working draft of the CSS level 4 selectors which outlines the experimental new selectors and experimental behavioral changes. HTML5 The HTML 5.0 specification document. Defines the semantics regarding HTML. HTML Living Standard The HTML Living Standard document. Defines semantics regarding HTML. Working Draft Selectors If at anytime a working draft drops a selector from the current draft, it will most likely also be removed here, most likely with a deprecation path, except where there may be a conflict that requires a less graceful transition. One exception is in the rare case that the selector is found to be far too useful despite being rejected. In these cases, we may adopt them as \"custom\" selectors. Not Implemented Pseudo elements are not supported as they do not represent real elements. At-rules ( @page , etc.) are also not supported. Escapes \ue157 Soup Sieve selectors support using CSS escapes. So if you need provide Unicode, or non-standard characters, you can use CSS style escapes. Escapes can be specified with a backslash followed by 1 - 6 hexadecimal digits: \\ 20AC , \\ 0020AC , etc. If you need to terminate an escape to avoid it accumulating unintended hexadecimal characters, you can use a space: \\ 0020AC dont-escape-me . You can also escape any non-hexadecimal character, and it will be treated as that character: \\ + \u2192 + . The one exception is that you cannot escape the form feed, newline, or carriage return. Basic Selectors \ue157 Type Selectors \ue157 Type selectors match elements by node name. If a default namespace is defined in the namespace dictionary , and no namespace is explicitly defined, it will be assumed that the element must be in the default namespace. Type Example The following would select all < div > elements. div Universal Selectors \ue157 The Universal selector ( * ) matches elements of any type. Example The following would match any element: div , a , p , etc. * ID Selectors \ue157 The ID selector matches an element based on its id attribute. The ID must match exactly. Example The following would select the element with the id some-id . # some-id Class Selectors \ue157 The class selector matches an element based on the values contained in the class attribute. The class attribute is treated as a whitespace separated list, where each item is a class . Example The following would select the elements with the class some-class . . some-class Attribute Selectors \ue157 The attribute selector matches an element based on its attributes. When specifying a value of an attribute, if it contains whitespace or special characters, you should quote them with either single or double quotes. [attribute] Represents elements with an attribute named attribute . Example The following would select all elements with a target attribute. [ target ] [attribute=value] Represents elements with an attribute named attribute that also has a value of value . Example The following would select all elements with the target attribute whose value was _blank . [ target = _blank ] [attribute~=value] Represents elements with an attribute named attribute whose value is a space separated list which contains value . Example The following would select all elements with a title attribute containing the word flower . [ title ~= flower ] [attribute|=value] Represents elements with an attribute named attribute whose value is a dash separated list that starts with value . Example The following would select all elements with a lang attribute value starting with en . [ lang |= en ] [attribute^=value] Represents elements with an attribute named attribute whose value starts with value . Example The following selects every < a > element whose href attribute value begins with https . a [ href ^= \"https\" ] [attribute$=value] Represents elements with an attribute named attribute whose value ends with value . Example The following would select every < a > element whose href attribute value ends with .pdf . a [ href $= \".pdf\" ] [attribute*=value] Represents elements with an attribute named attribute whose value containing the substring value . Example The following would select every < a > element whose href attribute value contains the substring sometext . a [ href *= \"sometext\" ] [attribute!=value] Equivalent to : not ([ attribute = value ]) . Example Selects all elements who do not have a target attribute or do not have one with a value that matches _blank . [ target != _blank ] [attribute operator value i] Represents elements with an attribute named attribute and whose value, when the operator is applied, matches value without case sensitivity. Example The following would select any element with a title that equals flower regardless of case. [ title = flower i ] [attribute operator value s] Represents elements with an attribute named attribute and whose value, when the operator is applied, matches value with case sensitivity. Example The following would select any element with a type that equals submit . Case sensitivity will be forced. [ type = submit s ] Namespace Selectors \ue157 Namespace selectors are used in conjunction with type selectors. They are specified with by declaring the namespace and the type separated with | : namespace|type . namespace in this context is the prefix defined via the namespace dictionary . The prefix does not need to match the prefix in the document as it is the namespace that is compared, not the prefix. The universal selector ( * ) can be used to represent any namespace as it can with type. Namespaces can be used with attribute selectors as well except that when [|attribute ] is used, it is equivalent to [attribute] . *|* Represents any element with or without a namespace. Example The following would select the < div > element with or without a namespace. *| div namespace|* Represents any element with a namespace that is associated with the prefix namespace as defined in the namespace dictionary . Example The following would select the < circle > element with the namespace svg . svg | circle |* Represents any element with no defined namespace. Example The following would select a < div > element that has no namespace. | div Combinators and Selector Lists \ue157 CSS employs a number of tokens in order to represent lists or to provide relational context between two selectors. Selector Lists \ue157 Selector lists use the comma ( , ) to join multiple selectors in a list. Example The following would select both < div > elements and < h1 > elements. div, h1 Descendant Combinator \ue157 Descendant combinators combine two selectors with whitespace ( ) in order to signify that the second element is matched if it has an ancestor that matches the first element. Example The following would select all < p > elements inside < div > elements. div p Child combinator \ue157 Child combinators combine two selectors with > in order to signify that the second element is matched if it has a parent that matches the first element. Example The following would select all < p > elements where the parent is a < div > element. div > p General sibling combinator \ue157 General sibling combinators combine two selectors with ~ in order to signify that the second element is matched if it has a sibling that precedes it that matches the first element. Example The following would select every < ul > element that is preceded by a < p > element. p ~ ul Adjacent sibling combinator \ue157 Adjacent sibling combinators combine two selectors with + in order to signify that the second element is matched if it has an adjacent sibling that precedes it that matches the first element. Example The following would select all < p > elements that are placed immediately after < div > elements. div + p Pseudo-Classes \ue157 :active \ue157 Selects active elements. Example Active states are not applicable, so this will never match. a : active :any-link \ue157 Selects every < a > , < area > , or < link > element that has an href attribute, independent of whether it has been visited. Example All links are treated as unvisited, so this will match every < a > element with an href attribute. a : any-link :checked \ue157 Selects any < input type = \"radio\" /> , < input type = \"checkbox\" /> , or < option > element (in a < select > element) that is checked or toggled to an on state. Example Selects every checked < input > element. input : checked :contains \ue157 Selects elements that contain the text provided text. Text can be found in either itself, or its descendants. Contains :contains() is an expensive operation as it scans all the text nodes of an element under consideration, which includes all descendants. Using highly specific selectors can reduce how often it is evaluated. Example Select all < p > elements that contain \"text\" in their content. p : contains ( text ) :current \ue157 :current Selects the element, or an ancestor of the element, that is currently being displayed. Example Time-dimensional pseudo-classes require a user agent which is not present in Beautiful Soup, so this will match nothing. p : current :current(sel1, sel2, ...) The functional form is like :is() and takes a selector list: Example Time-dimensional pseudo-classes require a user agent which is not present in Beautiful Soup, so this will match nothing. : current ( p , li , dt , dd ) :default \ue157 Selects any form element that is the default among a group of related elements, including: < button > , < input type = \"checkbox\" > , < input type = \"radio\" > , < option > elements. Example Selects all < inputs > elements that are the default among their related elements. input : default :defined \ue157 Normally, this represents normal elements (names without hyphens) and custom elements (names with hyphens) that have been properly added to the custom element registry. Since elements cannot be added to a custom element registry in Beautiful Soup, this will select all elements that are not custom tags. :defined is a HTML specific selector, so it doesn't apply to XML. Example Selects all defined elements under body. body : defined :dir() \ue157 Selects elements based on text directionality. Accepts either ltr or rtl for \"left to right\" and \"right to left\" respectively. Example Selects all < div > elements that have a text direction of left to right. div : dir ( ltr ) :disabled \ue157 Selects any element that is disabled. Example Selects every disabled < input > element. input : disabled :empty \ue157 Selects elements that have no children and no text (whitespace is ignored). Example Selects every < p > element that has no children and either no text. p : empty :enabled \ue157 Selects any element that is enabled. Example Selects every enabled < input > element. input : enabled :first-child \ue157 Selects the first child in a group of sibling elements. Example Selects every < p > that is also the first child of its parent. p : first-child :first-of-type \ue157 Selects the first child of a given type in a group of sibling elements. Example Selects every < p > element that is the first < p > element of its parent. p : first-of-type :focus \ue157 Represents an an element that has received focus. Example Focus states are not possible in Beautiful Soup, so this will never match. input : focus :focus-visible \ue157 Selects an element that matches :focus and the user agent determines that the focus should be made evident on the element. Example Focus states are not possible in Beautiful Soup, and since a user agent also needs to raise that the focus should be made evident, this will never match. a : focus-visible :focus-within \ue157 Selects an element that has received focus or contains an element that has received focus. Example Focus states are not possible in Beautiful Soup, so this will never match. div : focus-within :future \ue157 Selects an element that is defined to occur entirely after a :current element. Example Time-dimensional pseudo-classes require a user agent which is not present in Beautiful Soup, so this will match nothing. p : future :has() \ue157 Selects an element if any of the relative selectors passed as parameters (which are relative to the :scope of the given element), match at least one element. Example Selects elements that have a direct child that is a < div > or that have a sibling of < p > immediately following it. : has (> div , + p ) :host \ue157 :host Select the element hosting a shadow tree. Example Matches nothing as there is no Shadow DOM in Beautiful Soup. : host :host(sel1, sel2, ...) The functional form of :host takes a selector list and matches the shadow host only if it matches one of the selectors in the list. Example Matches nothing as there is no Shadow DOM in Beautiful Soup. : host ( h1 ) :host-context() \ue157 Selects the element hosting shadow tree, but only if one of the element's ancestors match a selector in the selector list. Example Matches nothing as there is no Shadow DOM in Beautiful Soup. : host-context ( main article ) :hover \ue157 Selects an element when the user interacts with it by hovering over it with a pointing device. Example Hovering is not possible in Beautiful Soup, so this will match nothing. a : hover :in-range \ue157 Selects all < input > elements whose values are in range according to their type , min , and max attributes. Example Matches all < input type = \"number\" /> elements whose values are in range. input [ type = \"number\" ] : in-range :indeterminate \ue157 Selects all form elements whose are in an indeterminate state. Example Matches all < input type = \"radio\" /> elements that are in a form and none of the other radio controls with the same name are selected. input [ type = \"radio\" ] : indeterminate :is() \ue157 Selects an element, but only if it matches at least one selector in the selector list. Example Matches < div > elements and < p > elements. : is ( div , p ) :lang() \ue157 :lang(language) Selects an element whose associated language matches the provided language or whose language starts with the provided language followed by a - . Language is determined by the rules of the document type. Example Selects all elements with language en . Will also match languages of en-US , en-GB , etc. : lang ( en ) :lang(language1, language2, ...) The level 4 :lang() adds the ability to define multiple languages, the ability to use * for wildcard language matching. Example Select all elements with language de-CH , it-CH , fr-CH , and rm-CH . Will also match en , en-US , and en-GB . See CSS4 specification for more info on wildcard matching rules. : lang ( '*-CH' , en ) :last-child \ue157 Selects the last element among a group of sibling elements. Example Selects every < p > element that is also the last child of its parent. p : last-child :last-of-type \ue157 Selects the last child of a given type in a group of sibling elements. Example Selects every < p > element that is the last < p > element of its parent. p : last-of-type :link \ue157 Selects a link (every < a > , < link > , and < area > element with an href attribute) that has not yet been visited. Example Selects all < a > elements since Beautiful Soup does not have visited states. a : link :local-link \ue157 Selects link (every < a > , < link > , and < area > element with an href attribute) elements whose absolute URL matches the element\u2019s own document URL. Example Since documents in Beautiful Soup are not live documents, they do not contain the context of the document's URL, so this will not match anything. a : local-link :not() \ue157 :not(selector) Selects all elements that do not match the selector. Example Selects all < p > elements that do not have class exclude . p : not ( . exclude ) :not(selector1, selector2, ...) Selects all elements that do not match any of the selectors in the selector list. Example Selects all < p > elements that do not have class exclude and attribute style . p : not ( . exclude , [ style ]) :nth-child() \ue157 :nth-child(keyword) :nth-child allows the keywords even and odd , and will respectively select elements whose position is either even or odd amongst a group of siblings. Example Select every odd element that is also a < p > element. p : nth-child ( odd ) :nth-child(an+b) Selects elements based on their position in a group of siblings, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Example Selects the first three elements: 1 = 1*0+3 , 2 = -1*1+3 , 3 = -1*2+3 . : nth-child ( -n + 3 ) :nth-child(an+b [of S]?) Selects from a sub-group of sibling elements that all match the selector list ( [of S]? ), based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Essentially, img : nth-of-type ( 2 ) would be equivalent to : nth-child ( 2 of img ) . The advantage of this of using :nth-child(an+b [of S]?) is that :nth-of-type is restricted to types, while :nth-child(an+b [of S]?) can use compound selectors. Example Selects the second element of a group of sibling elements that match all match img . : nth-child ( 2 of img ) :nth-last-child() \ue157 :nth-last-child(keyword) :nth-last-child allows the keywords even and odd , and will respectively select elements whose position is either even or odd amongst a group of siblings, counting from the end. Example Select every odd element that is also a < p > element, counting from the end. p : nth-child ( odd ) :nth-last-child(an+b) Counting from the end, selects elements based on their position in a group of siblings, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Example Selects the last three elements: 1 = 1*0+3 , 2 = -1*1+3 , 3 = -1*2+3 . : nth-child ( -n + 3 ) :nth-last-child(an+b [of S]?) Counting from the end, selects from a sub-group of sibling elements that all match the selector list ( [of S]? ), based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Essentially, img : nth-last-of-type ( 2 ) would be equivalent to : nth-last-child ( 2 of img ) . The advantage of this of using :nth-last-child(an+b [of S]?) is that :nth-last-of-type is restricted to types, while :nth-last-child(an+b [of S]?) can use compound selectors. Example Selects the second element (counting from the end) of a group of sibling elements that match all match img . : nth-last-child ( 2 of img ) :nth-last-of-type() \ue157 :nth-last-of-type(keyword) :nth-last-of-type allows the keywords even and odd , and will respectively select elements, from a sub-group of sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of siblings, counting from the end. Example Counting from the end, selects every even < p > amongst sibling < p > elements. p : nth-last-of-type ( even ) :nth-last-of-child(an+b) Counting from the end, selects from a sub-group of sibling elements that all match the given type, based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Example Counting from the end, selects every < p > element that is the second < p > element of its parent. p : nth-last-of-type ( 2 ) :nth-of-type() \ue157 :nth-of-type(keyword) :nth-of-type allows the keywords even and odd , and will respectively select elements, from a sub-group of sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of siblings. Example Selects every even < p > amongst sibling < p > elements. p : nth-last-of-type ( even ) :nth-of-type(an+b) Selects from a sub-group of sibling elements that all match the given type, based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Example Selects every < p > element that is the second < p > element of its parent. p : nth-of-type ( 2 ) :only-child \ue157 Selects element without any siblings. Example Selects any < p > element that is the only child of its parent. p : only-child :only-of-type \ue157 Selects element without any siblings that matches a given type. Example Selects every < p > element that is the only < p > element of its parent. p : only-of-type :optional \ue157 Selects any < input > , < select > , or < textarea > element that does not have the required attribute set on it. Example Select every < input > element without a required attribute. input : optional :out-of-range \ue157 Selects all < input > elements whose values are out of range according to their type , min , and max attributes. Example Matches all < input type = \"number\" /> elements whose values are out of range. input [ type = \"number\" ] : out-of-range :past \ue157 Selects an element that is defined to occur entirely prior to a :current element. Example Time-dimensional pseudo-classes require a user agent which is not present in Beautiful Soup, so this will match nothing. p : past :paused \ue157 Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \"paused\". Example It is not possible to play or pause a media element in Beautiful Soup, so this will match nothing. : paused :placeholder-shown \ue157 Selects any < input > or < textarea > element that is currently displaying placeholder text via the placeholder attribute. Example Matches all < input > elements that have placeholder text that is shown. input : placeholder-shown :playing \ue157 Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \u201cplaying\u201d. Example It is not possible to play or pause a media element in Beautiful Soup, so this will match nothing. : playing :read-only \ue157 Selects elements (such as < input > or < textarea > ) that are not editable by the user. This does not just apply to form elements with readonly set, but it applies to any element that cannot be edited by the user. Example Selects every < input > element that is not editable by the user. input : read-only :read-write \ue157 Selects elements (such as < input > or < textarea > ) that are editable by the user. This does not just apply to form elements as it applies to any element that can be edited by the user, such as a < p > element with contenteditable set on it. Example Selects every < input > element that is editable by the user. input : read-only :required \ue157 Selects any < input > , < select > , or < textarea > element that has the required attribute set on it. Example Select every < input > element with a required attribute. input : required :root \ue157 Selects the root element of a document tree. Example For HTML, this would select the < html > element. : root :scope \ue157 :scope represents the the element a match , select , or filter is being called on. If we had were for instance using scope in on a div ( sv . select ( ':scope > p' , soup . div ) ) soup would represent that div element, and no others. If called on the Beautiful Soup object which represents the entire document, it would simply select :root . Example Assuming that the following selector was called on a div element, it would select all < p > elements that are direct children of that associated < div > element. : scope > p :target \ue157 Selects a unique element (the target element) with an id matching the URL's fragment. Example Since there is no concept of a \"targeted\" element outside a user agent/browser without simulation, this will match nothing. h1 : target :target-within \ue157 Selects a unique element with an id matching the URL's fragment or an element which contains the element. Example Since there is no concept of a \"targeted\" element outside a user agent/browser without simulation, this will match nothing. div : target-within :user-invalid \ue157 Selects an element with incorrect input, but only after the user has significantly interacted with it. Example Since a user cannot interact with the HTML outside a user agent (or some simulated environment), this will match nothing. input : user-invalid :visited \ue157 Selects links that have already been visited. Example In the Beautiful Soup, links cannot be \"visited\", that is a concept that only applies with a user agent/browser. As all links in Beautiful Soup are considered to be unvisited, this will match nothing. a : visited :where() \ue157 Selects an element, but only if it matches at least one selector in the selector list. In browsers, this also has zero specificity, but this only has relevance in a browser environment where you have multiple CSS styles, and specificity is used to see which applies. Beautiful Soup and Soup Sieve don't care about specificity. Example Matches < div > elements and < p > elements. : where ( div , p ) span.lab::after, span.html5::after, span.null::after, span.star::after { position: relative; display: inline-block; font: normal normal normal 16px/1 FontAwesome; padding-right: .50rem; -moz-osx-font-smoothing: initial; -webkit-font-smoothing: initial; font-weight: 400; } .badge { float: right; } span.lab::after { color: purple; content: '\\f0c3'; } span.html5::after { color: orange; content: '\\f13b'; } span.null::after { color: red; content: '\\f071' } span.star::after { color: green; content: '\\f005' }","title":"CSS Selectors"},{"location":"selectors/#css-selectors","text":"The CSS selectors are based off of the CSS level 4 specification. Primarily support has been added for selectors that were feasible to implement and most likely to get practical use. When speaking about namespaces, they only apply to XML, XHTML, or when dealing with recognized foreign tags in HTML5. Currently, Beautiful Soup's html5lib parser is the only parser that will return the appropriate namespaces for a HTML5 document. If you are using XHTML, you have to use the Beautiful Soup's lxml-xml parser (or xml for short) to get the appropriate namespaces in an XHTML document. In addition to using the correct parser, you must provide a dictionary of namespaces to Soup Sieve in order to use namespace selectors. See the documentation on namespaces to learn more. While an effort is made to mimic CSS selector behavior, there may be some differences or quirks, please report issues if any are found. Symbol Description Some selectors are dependent upon certain states in a web browser or other context which is simply not present outside a web browser. An example would be the :focus selector. In Soup Sieve, :focus will match nothing because elements cannot be focused outside of a browser without simulation, or somehow connecting to a browser. These types of selectors, that provide no meaningful information in Soup Sieve, will be marked with . Some selectors are very specific to HTML and either have no meaningful representation in XML, or such functionality has not been implemented. Selectors that are HTML only will be noted with , and will match nothing if used in XML. Soup Sieve has implemented a couple non-standard selectors. These can contain useful selectors that were rejected from the official CSS specifications, selectors implemented by other systems such as JQuery, or even selectors specifically created for Soup Sieve. If a selector is considered non standard, it will be marked with . All selectors that are from the current working draft of CSS4 are considered experimental and are marked with . Additionally, if there are other immature selectors, they may be marked as experimental as well. Experimental may mean we are not entirely sure if our implementation is correct, that things may still be in flux as they are part of a working draft, or even both. Additional Reading If usage of a selector is not clear in this documentation, you can find more information by reading these specification documents: CSS Level 3 Specification Contains the latest official document outlying official behaviors of CSS selectors. CSS Level 4 Working Draft Contains the latest published working draft of the CSS level 4 selectors which outlines the experimental new selectors and experimental behavioral changes. HTML5 The HTML 5.0 specification document. Defines the semantics regarding HTML. HTML Living Standard The HTML Living Standard document. Defines semantics regarding HTML. Working Draft Selectors If at anytime a working draft drops a selector from the current draft, it will most likely also be removed here, most likely with a deprecation path, except where there may be a conflict that requires a less graceful transition. One exception is in the rare case that the selector is found to be far too useful despite being rejected. In these cases, we may adopt them as \"custom\" selectors. Not Implemented Pseudo elements are not supported as they do not represent real elements. At-rules ( @page , etc.) are also not supported.","title":"CSS Selectors"},{"location":"selectors/#escapes","text":"Soup Sieve selectors support using CSS escapes. So if you need provide Unicode, or non-standard characters, you can use CSS style escapes. Escapes can be specified with a backslash followed by 1 - 6 hexadecimal digits: \\ 20AC , \\ 0020AC , etc. If you need to terminate an escape to avoid it accumulating unintended hexadecimal characters, you can use a space: \\ 0020AC dont-escape-me . You can also escape any non-hexadecimal character, and it will be treated as that character: \\ + \u2192 + . The one exception is that you cannot escape the form feed, newline, or carriage return.","title":"Escapes"},{"location":"selectors/#basic-selectors","text":"","title":"Basic Selectors"},{"location":"selectors/#type-selectors","text":"Type selectors match elements by node name. If a default namespace is defined in the namespace dictionary , and no namespace is explicitly defined, it will be assumed that the element must be in the default namespace. Type Example The following would select all < div > elements. div","title":"Type Selectors"},{"location":"selectors/#universal-selectors","text":"The Universal selector ( * ) matches elements of any type. Example The following would match any element: div , a , p , etc. *","title":"Universal Selectors"},{"location":"selectors/#id-selectors","text":"The ID selector matches an element based on its id attribute. The ID must match exactly. Example The following would select the element with the id some-id . # some-id","title":"ID Selectors"},{"location":"selectors/#class-selectors","text":"The class selector matches an element based on the values contained in the class attribute. The class attribute is treated as a whitespace separated list, where each item is a class . Example The following would select the elements with the class some-class . . some-class","title":"Class Selectors"},{"location":"selectors/#attribute-selectors","text":"The attribute selector matches an element based on its attributes. When specifying a value of an attribute, if it contains whitespace or special characters, you should quote them with either single or double quotes. [attribute] Represents elements with an attribute named attribute . Example The following would select all elements with a target attribute. [ target ] [attribute=value] Represents elements with an attribute named attribute that also has a value of value . Example The following would select all elements with the target attribute whose value was _blank . [ target = _blank ] [attribute~=value] Represents elements with an attribute named attribute whose value is a space separated list which contains value . Example The following would select all elements with a title attribute containing the word flower . [ title ~= flower ] [attribute|=value] Represents elements with an attribute named attribute whose value is a dash separated list that starts with value . Example The following would select all elements with a lang attribute value starting with en . [ lang |= en ] [attribute^=value] Represents elements with an attribute named attribute whose value starts with value . Example The following selects every < a > element whose href attribute value begins with https . a [ href ^= \"https\" ] [attribute$=value] Represents elements with an attribute named attribute whose value ends with value . Example The following would select every < a > element whose href attribute value ends with .pdf . a [ href $= \".pdf\" ] [attribute*=value] Represents elements with an attribute named attribute whose value containing the substring value . Example The following would select every < a > element whose href attribute value contains the substring sometext . a [ href *= \"sometext\" ] [attribute!=value] Equivalent to : not ([ attribute = value ]) . Example Selects all elements who do not have a target attribute or do not have one with a value that matches _blank . [ target != _blank ] [attribute operator value i] Represents elements with an attribute named attribute and whose value, when the operator is applied, matches value without case sensitivity. Example The following would select any element with a title that equals flower regardless of case. [ title = flower i ] [attribute operator value s] Represents elements with an attribute named attribute and whose value, when the operator is applied, matches value with case sensitivity. Example The following would select any element with a type that equals submit . Case sensitivity will be forced. [ type = submit s ]","title":"Attribute Selectors"},{"location":"selectors/#namespace-selectors","text":"Namespace selectors are used in conjunction with type selectors. They are specified with by declaring the namespace and the type separated with | : namespace|type . namespace in this context is the prefix defined via the namespace dictionary . The prefix does not need to match the prefix in the document as it is the namespace that is compared, not the prefix. The universal selector ( * ) can be used to represent any namespace as it can with type. Namespaces can be used with attribute selectors as well except that when [|attribute ] is used, it is equivalent to [attribute] . *|* Represents any element with or without a namespace. Example The following would select the < div > element with or without a namespace. *| div namespace|* Represents any element with a namespace that is associated with the prefix namespace as defined in the namespace dictionary . Example The following would select the < circle > element with the namespace svg . svg | circle |* Represents any element with no defined namespace. Example The following would select a < div > element that has no namespace. | div","title":"Namespace Selectors"},{"location":"selectors/#combinators-and-selector-lists","text":"CSS employs a number of tokens in order to represent lists or to provide relational context between two selectors.","title":"Combinators and Selector Lists"},{"location":"selectors/#selector-lists","text":"Selector lists use the comma ( , ) to join multiple selectors in a list. Example The following would select both < div > elements and < h1 > elements. div, h1","title":"Selector Lists"},{"location":"selectors/#descendant-combinator","text":"Descendant combinators combine two selectors with whitespace ( ) in order to signify that the second element is matched if it has an ancestor that matches the first element. Example The following would select all < p > elements inside < div > elements. div p","title":"Descendant Combinator"},{"location":"selectors/#child-combinator","text":"Child combinators combine two selectors with > in order to signify that the second element is matched if it has a parent that matches the first element. Example The following would select all < p > elements where the parent is a < div > element. div > p","title":"Child combinator"},{"location":"selectors/#general-sibling-combinator","text":"General sibling combinators combine two selectors with ~ in order to signify that the second element is matched if it has a sibling that precedes it that matches the first element. Example The following would select every < ul > element that is preceded by a < p > element. p ~ ul","title":"General sibling combinator"},{"location":"selectors/#adjacent-sibling-combinator","text":"Adjacent sibling combinators combine two selectors with + in order to signify that the second element is matched if it has an adjacent sibling that precedes it that matches the first element. Example The following would select all < p > elements that are placed immediately after < div > elements. div + p","title":"Adjacent sibling combinator"},{"location":"selectors/#pseudo-classes","text":"","title":"Pseudo-Classes"},{"location":"selectors/#:active","text":"Selects active elements. Example Active states are not applicable, so this will never match. a : active","title":":active"},{"location":"selectors/#:any-link","text":"Selects every < a > , < area > , or < link > element that has an href attribute, independent of whether it has been visited. Example All links are treated as unvisited, so this will match every < a > element with an href attribute. a : any-link","title":":any-link"},{"location":"selectors/#:checked","text":"Selects any < input type = \"radio\" /> , < input type = \"checkbox\" /> , or < option > element (in a < select > element) that is checked or toggled to an on state. Example Selects every checked < input > element. input : checked","title":":checked"},{"location":"selectors/#:contains","text":"Selects elements that contain the text provided text. Text can be found in either itself, or its descendants. Contains :contains() is an expensive operation as it scans all the text nodes of an element under consideration, which includes all descendants. Using highly specific selectors can reduce how often it is evaluated. Example Select all < p > elements that contain \"text\" in their content. p : contains ( text )","title":":contains"},{"location":"selectors/#:current","text":":current Selects the element, or an ancestor of the element, that is currently being displayed. Example Time-dimensional pseudo-classes require a user agent which is not present in Beautiful Soup, so this will match nothing. p : current :current(sel1, sel2, ...) The functional form is like :is() and takes a selector list: Example Time-dimensional pseudo-classes require a user agent which is not present in Beautiful Soup, so this will match nothing. : current ( p , li , dt , dd )","title":":current"},{"location":"selectors/#:default","text":"Selects any form element that is the default among a group of related elements, including: < button > , < input type = \"checkbox\" > , < input type = \"radio\" > , < option > elements. Example Selects all < inputs > elements that are the default among their related elements. input : default","title":":default"},{"location":"selectors/#:defined","text":"Normally, this represents normal elements (names without hyphens) and custom elements (names with hyphens) that have been properly added to the custom element registry. Since elements cannot be added to a custom element registry in Beautiful Soup, this will select all elements that are not custom tags. :defined is a HTML specific selector, so it doesn't apply to XML. Example Selects all defined elements under body. body : defined","title":":defined"},{"location":"selectors/#:dir","text":"Selects elements based on text directionality. Accepts either ltr or rtl for \"left to right\" and \"right to left\" respectively. Example Selects all < div > elements that have a text direction of left to right. div : dir ( ltr )","title":":dir()"},{"location":"selectors/#:disabled","text":"Selects any element that is disabled. Example Selects every disabled < input > element. input : disabled","title":":disabled"},{"location":"selectors/#:empty","text":"Selects elements that have no children and no text (whitespace is ignored). Example Selects every < p > element that has no children and either no text. p : empty","title":":empty"},{"location":"selectors/#:enabled","text":"Selects any element that is enabled. Example Selects every enabled < input > element. input : enabled","title":":enabled"},{"location":"selectors/#:first-child","text":"Selects the first child in a group of sibling elements. Example Selects every < p > that is also the first child of its parent. p : first-child","title":":first-child"},{"location":"selectors/#:first-of-type","text":"Selects the first child of a given type in a group of sibling elements. Example Selects every < p > element that is the first < p > element of its parent. p : first-of-type","title":":first-of-type"},{"location":"selectors/#:focus","text":"Represents an an element that has received focus. Example Focus states are not possible in Beautiful Soup, so this will never match. input : focus","title":":focus"},{"location":"selectors/#:focus-visible","text":"Selects an element that matches :focus and the user agent determines that the focus should be made evident on the element. Example Focus states are not possible in Beautiful Soup, and since a user agent also needs to raise that the focus should be made evident, this will never match. a : focus-visible","title":":focus-visible"},{"location":"selectors/#:focus-within","text":"Selects an element that has received focus or contains an element that has received focus. Example Focus states are not possible in Beautiful Soup, so this will never match. div : focus-within","title":":focus-within"},{"location":"selectors/#:future","text":"Selects an element that is defined to occur entirely after a :current element. Example Time-dimensional pseudo-classes require a user agent which is not present in Beautiful Soup, so this will match nothing. p : future","title":":future"},{"location":"selectors/#has","text":"Selects an element if any of the relative selectors passed as parameters (which are relative to the :scope of the given element), match at least one element. Example Selects elements that have a direct child that is a < div > or that have a sibling of < p > immediately following it. : has (> div , + p )","title":":has()"},{"location":"selectors/#host","text":":host Select the element hosting a shadow tree. Example Matches nothing as there is no Shadow DOM in Beautiful Soup. : host :host(sel1, sel2, ...) The functional form of :host takes a selector list and matches the shadow host only if it matches one of the selectors in the list. Example Matches nothing as there is no Shadow DOM in Beautiful Soup. : host ( h1 )","title":":host"},{"location":"selectors/#:host-context","text":"Selects the element hosting shadow tree, but only if one of the element's ancestors match a selector in the selector list. Example Matches nothing as there is no Shadow DOM in Beautiful Soup. : host-context ( main article )","title":":host-context()"},{"location":"selectors/#:hover","text":"Selects an element when the user interacts with it by hovering over it with a pointing device. Example Hovering is not possible in Beautiful Soup, so this will match nothing. a : hover","title":":hover"},{"location":"selectors/#:in-range","text":"Selects all < input > elements whose values are in range according to their type , min , and max attributes. Example Matches all < input type = \"number\" /> elements whose values are in range. input [ type = \"number\" ] : in-range","title":":in-range"},{"location":"selectors/#:indeterminate","text":"Selects all form elements whose are in an indeterminate state. Example Matches all < input type = \"radio\" /> elements that are in a form and none of the other radio controls with the same name are selected. input [ type = \"radio\" ] : indeterminate","title":":indeterminate"},{"location":"selectors/#:is","text":"Selects an element, but only if it matches at least one selector in the selector list. Example Matches < div > elements and < p > elements. : is ( div , p )","title":":is()"},{"location":"selectors/#:lang","text":":lang(language) Selects an element whose associated language matches the provided language or whose language starts with the provided language followed by a - . Language is determined by the rules of the document type. Example Selects all elements with language en . Will also match languages of en-US , en-GB , etc. : lang ( en ) :lang(language1, language2, ...) The level 4 :lang() adds the ability to define multiple languages, the ability to use * for wildcard language matching. Example Select all elements with language de-CH , it-CH , fr-CH , and rm-CH . Will also match en , en-US , and en-GB . See CSS4 specification for more info on wildcard matching rules. : lang ( '*-CH' , en )","title":":lang()"},{"location":"selectors/#:last-child","text":"Selects the last element among a group of sibling elements. Example Selects every < p > element that is also the last child of its parent. p : last-child","title":":last-child"},{"location":"selectors/#:last-of-type","text":"Selects the last child of a given type in a group of sibling elements. Example Selects every < p > element that is the last < p > element of its parent. p : last-of-type","title":":last-of-type"},{"location":"selectors/#:link","text":"Selects a link (every < a > , < link > , and < area > element with an href attribute) that has not yet been visited. Example Selects all < a > elements since Beautiful Soup does not have visited states. a : link","title":":link"},{"location":"selectors/#:local-link","text":"Selects link (every < a > , < link > , and < area > element with an href attribute) elements whose absolute URL matches the element\u2019s own document URL. Example Since documents in Beautiful Soup are not live documents, they do not contain the context of the document's URL, so this will not match anything. a : local-link","title":":local-link"},{"location":"selectors/#:not","text":":not(selector) Selects all elements that do not match the selector. Example Selects all < p > elements that do not have class exclude . p : not ( . exclude ) :not(selector1, selector2, ...) Selects all elements that do not match any of the selectors in the selector list. Example Selects all < p > elements that do not have class exclude and attribute style . p : not ( . exclude , [ style ])","title":":not()"},{"location":"selectors/#:nth-child","text":":nth-child(keyword) :nth-child allows the keywords even and odd , and will respectively select elements whose position is either even or odd amongst a group of siblings. Example Select every odd element that is also a < p > element. p : nth-child ( odd ) :nth-child(an+b) Selects elements based on their position in a group of siblings, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Example Selects the first three elements: 1 = 1*0+3 , 2 = -1*1+3 , 3 = -1*2+3 . : nth-child ( -n + 3 ) :nth-child(an+b [of S]?) Selects from a sub-group of sibling elements that all match the selector list ( [of S]? ), based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Essentially, img : nth-of-type ( 2 ) would be equivalent to : nth-child ( 2 of img ) . The advantage of this of using :nth-child(an+b [of S]?) is that :nth-of-type is restricted to types, while :nth-child(an+b [of S]?) can use compound selectors. Example Selects the second element of a group of sibling elements that match all match img . : nth-child ( 2 of img )","title":":nth-child()"},{"location":"selectors/#:nth-last-child","text":":nth-last-child(keyword) :nth-last-child allows the keywords even and odd , and will respectively select elements whose position is either even or odd amongst a group of siblings, counting from the end. Example Select every odd element that is also a < p > element, counting from the end. p : nth-child ( odd ) :nth-last-child(an+b) Counting from the end, selects elements based on their position in a group of siblings, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Example Selects the last three elements: 1 = 1*0+3 , 2 = -1*1+3 , 3 = -1*2+3 . : nth-child ( -n + 3 ) :nth-last-child(an+b [of S]?) Counting from the end, selects from a sub-group of sibling elements that all match the selector list ( [of S]? ), based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Essentially, img : nth-last-of-type ( 2 ) would be equivalent to : nth-last-child ( 2 of img ) . The advantage of this of using :nth-last-child(an+b [of S]?) is that :nth-last-of-type is restricted to types, while :nth-last-child(an+b [of S]?) can use compound selectors. Example Selects the second element (counting from the end) of a group of sibling elements that match all match img . : nth-last-child ( 2 of img )","title":":nth-last-child()"},{"location":"selectors/#:nth-last-of-type","text":":nth-last-of-type(keyword) :nth-last-of-type allows the keywords even and odd , and will respectively select elements, from a sub-group of sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of siblings, counting from the end. Example Counting from the end, selects every even < p > amongst sibling < p > elements. p : nth-last-of-type ( even ) :nth-last-of-child(an+b) Counting from the end, selects from a sub-group of sibling elements that all match the given type, based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Example Counting from the end, selects every < p > element that is the second < p > element of its parent. p : nth-last-of-type ( 2 )","title":":nth-last-of-type()"},{"location":"selectors/#:nth-of-type","text":":nth-of-type(keyword) :nth-of-type allows the keywords even and odd , and will respectively select elements, from a sub-group of sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of siblings. Example Selects every even < p > amongst sibling < p > elements. p : nth-last-of-type ( even ) :nth-of-type(an+b) Selects from a sub-group of sibling elements that all match the given type, based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Example Selects every < p > element that is the second < p > element of its parent. p : nth-of-type ( 2 )","title":":nth-of-type()"},{"location":"selectors/#:only-child","text":"Selects element without any siblings. Example Selects any < p > element that is the only child of its parent. p : only-child","title":":only-child"},{"location":"selectors/#:only-of-type","text":"Selects element without any siblings that matches a given type. Example Selects every < p > element that is the only < p > element of its parent. p : only-of-type","title":":only-of-type"},{"location":"selectors/#:optional","text":"Selects any < input > , < select > , or < textarea > element that does not have the required attribute set on it. Example Select every < input > element without a required attribute. input : optional","title":":optional"},{"location":"selectors/#:out-of-range","text":"Selects all < input > elements whose values are out of range according to their type , min , and max attributes. Example Matches all < input type = \"number\" /> elements whose values are out of range. input [ type = \"number\" ] : out-of-range","title":":out-of-range"},{"location":"selectors/#:past","text":"Selects an element that is defined to occur entirely prior to a :current element. Example Time-dimensional pseudo-classes require a user agent which is not present in Beautiful Soup, so this will match nothing. p : past","title":":past"},{"location":"selectors/#:paused","text":"Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \"paused\". Example It is not possible to play or pause a media element in Beautiful Soup, so this will match nothing. : paused","title":":paused"},{"location":"selectors/#:placeholder-shown","text":"Selects any < input > or < textarea > element that is currently displaying placeholder text via the placeholder attribute. Example Matches all < input > elements that have placeholder text that is shown. input : placeholder-shown","title":":placeholder-shown"},{"location":"selectors/#:playing","text":"Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \u201cplaying\u201d. Example It is not possible to play or pause a media element in Beautiful Soup, so this will match nothing. : playing","title":":playing"},{"location":"selectors/#:read-only","text":"Selects elements (such as < input > or < textarea > ) that are not editable by the user. This does not just apply to form elements with readonly set, but it applies to any element that cannot be edited by the user. Example Selects every < input > element that is not editable by the user. input : read-only","title":":read-only"},{"location":"selectors/#:read-write","text":"Selects elements (such as < input > or < textarea > ) that are editable by the user. This does not just apply to form elements as it applies to any element that can be edited by the user, such as a < p > element with contenteditable set on it. Example Selects every < input > element that is editable by the user. input : read-only","title":":read-write"},{"location":"selectors/#:required","text":"Selects any < input > , < select > , or < textarea > element that has the required attribute set on it. Example Select every < input > element with a required attribute. input : required","title":":required"},{"location":"selectors/#:root","text":"Selects the root element of a document tree. Example For HTML, this would select the < html > element. : root","title":":root"},{"location":"selectors/#:scope","text":":scope represents the the element a match , select , or filter is being called on. If we had were for instance using scope in on a div ( sv . select ( ':scope > p' , soup . div ) ) soup would represent that div element, and no others. If called on the Beautiful Soup object which represents the entire document, it would simply select :root . Example Assuming that the following selector was called on a div element, it would select all < p > elements that are direct children of that associated < div > element. : scope > p","title":":scope"},{"location":"selectors/#:target","text":"Selects a unique element (the target element) with an id matching the URL's fragment. Example Since there is no concept of a \"targeted\" element outside a user agent/browser without simulation, this will match nothing. h1 : target","title":":target"},{"location":"selectors/#:target-within","text":"Selects a unique element with an id matching the URL's fragment or an element which contains the element. Example Since there is no concept of a \"targeted\" element outside a user agent/browser without simulation, this will match nothing. div : target-within","title":":target-within"},{"location":"selectors/#:user-invalid","text":"Selects an element with incorrect input, but only after the user has significantly interacted with it. Example Since a user cannot interact with the HTML outside a user agent (or some simulated environment), this will match nothing. input : user-invalid","title":":user-invalid"},{"location":"selectors/#:visited","text":"Selects links that have already been visited. Example In the Beautiful Soup, links cannot be \"visited\", that is a concept that only applies with a user agent/browser. As all links in Beautiful Soup are considered to be unvisited, this will match nothing. a : visited","title":":visited"},{"location":"selectors/#:where","text":"Selects an element, but only if it matches at least one selector in the selector list. In browsers, this also has zero specificity, but this only has relevance in a browser environment where you have multiple CSS styles, and specificity is used to see which applies. Beautiful Soup and Soup Sieve don't care about specificity. Example Matches < div > elements and < p > elements. : where ( div , p ) span.lab::after, span.html5::after, span.null::after, span.star::after { position: relative; display: inline-block; font: normal normal normal 16px/1 FontAwesome; padding-right: .50rem; -moz-osx-font-smoothing: initial; -webkit-font-smoothing: initial; font-weight: 400; } .badge { float: right; } span.lab::after { color: purple; content: '\\f0c3'; } span.html5::after { color: orange; content: '\\f13b'; } span.null::after { color: red; content: '\\f071' } span.star::after { color: green; content: '\\f005' }","title":":where()"},{"location":"about/changelog/","text":"Changelog \ue157 1.7.3 \ue157 FIX : Fix regression with tag names in regards to case sensitivity, and ensure there are tests to prevent breakage in the future. FIX : XHTML should always be case sensitive like XML. 1.7.2 \ue157 FIX : Fix HTML detection type selector. FIX : Fixes for :enabled and :disabled . FIX : Provide a way for Beautiful Soup to parse selectors in a quirks mode to mimic some of the quirks of the old select method prior to Soup Sieve, but with warnings. This is to help old scripts to not break during the transitional period with newest Beautiful Soup. In the future, these quirks will raise an exception as Soup Sieve requires selectors to follow the CSS specification. 1.7.1 \ue157 FIX : Fix issue with :has() selector where a leading combinator can only be provided in the first selector in a relative selector list. 1.7.0 \ue157 NEW : Add support for :in-range and :out-of-range selectors. ( #60 ) NEW : Add support for :defined selector. ( #76 ) FIX : Fix pickling issue when compiled selector contains a NullSelector object. ( #70 ) FIX : Better exception messages in the CSS selector parser and fix a position reporting issue that can occur in some exceptions. ( #72 , #73 ) FIX : Don't compare prefixes when evaluating attribute namespaces, compare the actual namespace. ( #75 ) FIX : Split whitespace attribute lists by all whitespace characters, not just space. FIX : :nth-* patterns were converting numbers to base 16 when they should have been converting to base 10. 1.6.2 \ue157 FIX : Fix pattern compile issues on Python < 2.7.4. FIX : Don't use \\d in Unicode Re patterns as they will contain characters outside the range of [0-9] . 1.6.1 \ue157 FIX : Fix warning about not importing Mapping from collections.abc . 1.6.0 \ue157 NEW : Add closest method to the API that matches closest ancestor. FIX : Add missing select_one reference to module's __all__ . 1.5.0 \ue157 NEW : Add select_one method like Beautiful Soup has. NEW : Add :dir() selector (HTML only). FIX : Fix issues when handling HTML fragments (elements without a BeautifulSoup object as a parent). FIX : Fix internal nth range check. 1.4.0 \ue157 NEW : Throw NotImplementedError for at-rules: @page , etc. NEW : Match nothing for :host , :host() , and :host-context() . NEW : Add support for :read-write and :read-only . NEW : Selector patterns can be annotated with CSS comments. FIX : \\r , \\n , and \\f cannot be escaped with \\ in CSS. You must use Unicode escapes. 1.3.1 \ue157 FIX : Fix issue with undefined namespaces. 1.3.0 \ue157 NEW : Add support for :scope . NEW : :user-invalid , :playing , :paused , and :local-link will not cause a failure, but all will match nothing as their use cases are not possible in an environment outside a web browser. FIX : Fix [attr~=value] handling of whitespace. According to the spec, if the value contains whitespace, or is an empty string, it should not match anything. FIX : Precompile internal patterns for pseudo-classes to prevent having to parse them again. 1.2.1 \ue157 FIX : More descriptive exceptions. Exceptions will also now mention position in the pattern that is problematic. FIX : filter ignores NavigableString objects in normal iterables and Tag iterables. Basically, it filters all Beautiful Soup document parts regardless of iterable type where as it used to only filter out a NavigableString in a Tag object. This is viewed as fixing an inconsistency. FIX : DEBUG flag has been added to help with debugging CSS selector parsing. This is mainly for development. FIX : If forced to search for language in meta tag, and no language is found, cache that there is no language in the meta tag to prevent searching again during the current select. FIX : If a non BeautifulSoup / Tag object is given to the API to compare against, raise a TypeError . 1.2.0 \ue157 NEW : Add Python 2.7 support. NEW : Remove old pre 1.0 deprecations. 1.1.0 \ue157 NEW : Adds support for [attr!=value] which is equivalent to :not([attr=value]) . NEW : Add support for :active , :focus , :hover , :visited , :target , :focus-within , :focus-visible , :target-within , :current() / :current , :past , and :future , but they will never match as these states don't exist in the Soup Sieve environment. NEW : Add support for :checked , :enabled , :disabled , :required , :optional , :default , and :placeholder-shown which will only match in HTML documents as these concepts are not defined in XML. NEW : Add support for :link and :any-link , both of which will target all <a> , <area> , and <link> elements with an href attribute as all links will be treated as unvisited in Soup Sieve. NEW : Add support for :lang() (CSS4) which works in XML and HTML. NEW : Users must install Beautiful Soup themselves. This requirement is removed in the hopes that Beautiful Soup may use this in the future. FIX : Attributes in the form prefix:attr can be matched with the form [prefix\\:attr] without specifying a namespaces if desired. FIX : Fix exception when [type] is used (with no value). 1.0.2 \ue157 FIX : Use proper CSS identifier patterns for tag names, classes, ids, etc. Things like #3 or #-3 should not match and should require #\\33 or #-\\33 . FIX : Do not raise NotImplementedError for supported pseudo classes/elements with bad syntax, instead raise SyntaxError . 1.0.1 \ue157 FIX : When giving a tag to select , it should only return the children of that tag, never the tag itself. FIX : For informational purposes, raise a NotImplementedError when an unsupported pseudo class is used. 1.0.0 \ue157 NEW : Official 1.0.0 release. 1.0.0b2 \ue157 NEW : Drop document flags. Document type can be detected from the Beautiful Soup object directly. FIX : CSS selectors should be evaluated with CSS whitespace rules. FIX : Processing instructions, CDATA, and declarations should all be ignored in :contains and child considerations for :empty . FIX : In Beautiful Soup, the document itself is the first tag. Do not match the \"document\" tag by returning false for any tag that doesn't have a parent. 1.0.0b1 \ue157 NEW : Add support for non-standard :contains() selector. FIX : Compare pseudo class names case insensitively when matching unexpected cases. FIX : Don't allow attribute case flags when no attribute value is defined. 0.6.0 \ue157 NEW : mode attribute is now called flags to allow for other options in the future. FIX : More corner cases for nth selectors. 0.5.3 \ue157 FIX : Previously, all pseudo classes' selector lists were evaluated as one big group, but now each pseudo classes' selector lists are evaluated separately. FIX : CSS selector tokens are not case sensitive. 0.5.2 \ue157 FIX : Add missing s flag to attribute selector for forced case sensitivity of attribute values. FIX : Relax attribute pattern matching to allow non-essential whitespace. FIX : Attribute selector flags themselves are not case sensitive. FIX : type attribute in HTML is handled special. While all other attributes values are case sensitive, type in HTML is usually treated special and is insensitive. In XML, this is not the case. 0.5.1 \ue157 FIX : Fix namespace check for :nth-of-type . 0.5.0 \ue157 NEW : Deprecate commentsiter and selectiter in favor of icomments and iselect . Expect removal in version 1.0. 0.4.0 \ue157 NEW : Initial prerelease.","title":"Changelog"},{"location":"about/changelog/#changelog","text":"","title":"Changelog"},{"location":"about/changelog/#173","text":"FIX : Fix regression with tag names in regards to case sensitivity, and ensure there are tests to prevent breakage in the future. FIX : XHTML should always be case sensitive like XML.","title":"1.7.3"},{"location":"about/changelog/#172","text":"FIX : Fix HTML detection type selector. FIX : Fixes for :enabled and :disabled . FIX : Provide a way for Beautiful Soup to parse selectors in a quirks mode to mimic some of the quirks of the old select method prior to Soup Sieve, but with warnings. This is to help old scripts to not break during the transitional period with newest Beautiful Soup. In the future, these quirks will raise an exception as Soup Sieve requires selectors to follow the CSS specification.","title":"1.7.2"},{"location":"about/changelog/#171","text":"FIX : Fix issue with :has() selector where a leading combinator can only be provided in the first selector in a relative selector list.","title":"1.7.1"},{"location":"about/changelog/#170","text":"NEW : Add support for :in-range and :out-of-range selectors. ( #60 ) NEW : Add support for :defined selector. ( #76 ) FIX : Fix pickling issue when compiled selector contains a NullSelector object. ( #70 ) FIX : Better exception messages in the CSS selector parser and fix a position reporting issue that can occur in some exceptions. ( #72 , #73 ) FIX : Don't compare prefixes when evaluating attribute namespaces, compare the actual namespace. ( #75 ) FIX : Split whitespace attribute lists by all whitespace characters, not just space. FIX : :nth-* patterns were converting numbers to base 16 when they should have been converting to base 10.","title":"1.7.0"},{"location":"about/changelog/#162","text":"FIX : Fix pattern compile issues on Python < 2.7.4. FIX : Don't use \\d in Unicode Re patterns as they will contain characters outside the range of [0-9] .","title":"1.6.2"},{"location":"about/changelog/#161","text":"FIX : Fix warning about not importing Mapping from collections.abc .","title":"1.6.1"},{"location":"about/changelog/#160","text":"NEW : Add closest method to the API that matches closest ancestor. FIX : Add missing select_one reference to module's __all__ .","title":"1.6.0"},{"location":"about/changelog/#150","text":"NEW : Add select_one method like Beautiful Soup has. NEW : Add :dir() selector (HTML only). FIX : Fix issues when handling HTML fragments (elements without a BeautifulSoup object as a parent). FIX : Fix internal nth range check.","title":"1.5.0"},{"location":"about/changelog/#140","text":"NEW : Throw NotImplementedError for at-rules: @page , etc. NEW : Match nothing for :host , :host() , and :host-context() . NEW : Add support for :read-write and :read-only . NEW : Selector patterns can be annotated with CSS comments. FIX : \\r , \\n , and \\f cannot be escaped with \\ in CSS. You must use Unicode escapes.","title":"1.4.0"},{"location":"about/changelog/#131","text":"FIX : Fix issue with undefined namespaces.","title":"1.3.1"},{"location":"about/changelog/#130","text":"NEW : Add support for :scope . NEW : :user-invalid , :playing , :paused , and :local-link will not cause a failure, but all will match nothing as their use cases are not possible in an environment outside a web browser. FIX : Fix [attr~=value] handling of whitespace. According to the spec, if the value contains whitespace, or is an empty string, it should not match anything. FIX : Precompile internal patterns for pseudo-classes to prevent having to parse them again.","title":"1.3.0"},{"location":"about/changelog/#121","text":"FIX : More descriptive exceptions. Exceptions will also now mention position in the pattern that is problematic. FIX : filter ignores NavigableString objects in normal iterables and Tag iterables. Basically, it filters all Beautiful Soup document parts regardless of iterable type where as it used to only filter out a NavigableString in a Tag object. This is viewed as fixing an inconsistency. FIX : DEBUG flag has been added to help with debugging CSS selector parsing. This is mainly for development. FIX : If forced to search for language in meta tag, and no language is found, cache that there is no language in the meta tag to prevent searching again during the current select. FIX : If a non BeautifulSoup / Tag object is given to the API to compare against, raise a TypeError .","title":"1.2.1"},{"location":"about/changelog/#120","text":"NEW : Add Python 2.7 support. NEW : Remove old pre 1.0 deprecations.","title":"1.2.0"},{"location":"about/changelog/#110","text":"NEW : Adds support for [attr!=value] which is equivalent to :not([attr=value]) . NEW : Add support for :active , :focus , :hover , :visited , :target , :focus-within , :focus-visible , :target-within , :current() / :current , :past , and :future , but they will never match as these states don't exist in the Soup Sieve environment. NEW : Add support for :checked , :enabled , :disabled , :required , :optional , :default , and :placeholder-shown which will only match in HTML documents as these concepts are not defined in XML. NEW : Add support for :link and :any-link , both of which will target all <a> , <area> , and <link> elements with an href attribute as all links will be treated as unvisited in Soup Sieve. NEW : Add support for :lang() (CSS4) which works in XML and HTML. NEW : Users must install Beautiful Soup themselves. This requirement is removed in the hopes that Beautiful Soup may use this in the future. FIX : Attributes in the form prefix:attr can be matched with the form [prefix\\:attr] without specifying a namespaces if desired. FIX : Fix exception when [type] is used (with no value).","title":"1.1.0"},{"location":"about/changelog/#102","text":"FIX : Use proper CSS identifier patterns for tag names, classes, ids, etc. Things like #3 or #-3 should not match and should require #\\33 or #-\\33 . FIX : Do not raise NotImplementedError for supported pseudo classes/elements with bad syntax, instead raise SyntaxError .","title":"1.0.2"},{"location":"about/changelog/#101","text":"FIX : When giving a tag to select , it should only return the children of that tag, never the tag itself. FIX : For informational purposes, raise a NotImplementedError when an unsupported pseudo class is used.","title":"1.0.1"},{"location":"about/changelog/#100","text":"NEW : Official 1.0.0 release.","title":"1.0.0"},{"location":"about/changelog/#100b2","text":"NEW : Drop document flags. Document type can be detected from the Beautiful Soup object directly. FIX : CSS selectors should be evaluated with CSS whitespace rules. FIX : Processing instructions, CDATA, and declarations should all be ignored in :contains and child considerations for :empty . FIX : In Beautiful Soup, the document itself is the first tag. Do not match the \"document\" tag by returning false for any tag that doesn't have a parent.","title":"1.0.0b2"},{"location":"about/changelog/#100b1","text":"NEW : Add support for non-standard :contains() selector. FIX : Compare pseudo class names case insensitively when matching unexpected cases. FIX : Don't allow attribute case flags when no attribute value is defined.","title":"1.0.0b1"},{"location":"about/changelog/#060","text":"NEW : mode attribute is now called flags to allow for other options in the future. FIX : More corner cases for nth selectors.","title":"0.6.0"},{"location":"about/changelog/#053","text":"FIX : Previously, all pseudo classes' selector lists were evaluated as one big group, but now each pseudo classes' selector lists are evaluated separately. FIX : CSS selector tokens are not case sensitive.","title":"0.5.3"},{"location":"about/changelog/#052","text":"FIX : Add missing s flag to attribute selector for forced case sensitivity of attribute values. FIX : Relax attribute pattern matching to allow non-essential whitespace. FIX : Attribute selector flags themselves are not case sensitive. FIX : type attribute in HTML is handled special. While all other attributes values are case sensitive, type in HTML is usually treated special and is insensitive. In XML, this is not the case.","title":"0.5.2"},{"location":"about/changelog/#051","text":"FIX : Fix namespace check for :nth-of-type .","title":"0.5.1"},{"location":"about/changelog/#050","text":"NEW : Deprecate commentsiter and selectiter in favor of icomments and iselect . Expect removal in version 1.0.","title":"0.5.0"},{"location":"about/changelog/#040","text":"NEW : Initial prerelease.","title":"0.4.0"},{"location":"about/contributing/","text":"Contributing & Support \ue157 Bug Reports \ue157 Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much information as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code \ue157 Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Answer Questions in Issues \ue157 Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others. Pull Requests \ue157 Pull requests are welcome, and a great way to help fix bugs and add new features. If you you are interested in directly contributing to the code, please check out Development for more information on the environment and processes. Documentation Improvements \ue157 A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool by helping to improve the documentation. Check out Development for more info on documentation.","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much information as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#answer-questions-in-issues","text":"Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others.","title":"Answer Questions in Issues"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and a great way to help fix bugs and add new features. If you you are interested in directly contributing to the code, please check out Development for more information on the environment and processes.","title":"Pull Requests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool by helping to improve the documentation. Check out Development for more info on documentation.","title":"Documentation Improvements"},{"location":"about/development/","text":"Development \ue157 Project Layout \ue157 There are a number of files for build, test, and continuous integration in the root of the project, but in general, the project is broken up like so. \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 dictionary \u2502 \u2514\u2500\u2500 markdown \u251c\u2500\u2500 soupsieve \u251c\u2500\u2500 requirements \u2514\u2500\u2500 tests Directory Description docs/src/dictionary Contains the spell check wordlist(s) for the project. docs/src/markdown Contains the content for the documentation. soupsieve Contains the source code for the project. requirements Contains files with lists of dependencies that are required for the project, and required for continuous integration. tests Contains unit test files. Coding Standards \ue157 When writing code, the code should roughly conform to PEP8 and PEP257 suggestions. The project utilizes the Flake8 linter (with some additional plugins) to ensure code conforms (give or take some of the rules). When in doubt, follow the formatting hints of existing code when adding files or modifying existing files. Listed below are the modules used: pycqa/flake8 pycqa/flake8-docstrings pycqa/pep8-naming ebeweber/flake8-mutable gforcada/flake8-builtins Usually this can be automated with Tox (assuming it is installed): tox -e lint . Building and Editing Documents \ue157 Documents are in Markdown (with with some additional syntax provided by extensions) and are converted to HTML via Python Markdown. If you would like to build and preview the documentation, you must have these packages installed: Python-Markdown/markdown : the Markdown parser. mkdocs/mkdocs : the document site generator. squidfunk/mkdocs-material : a material theme for MkDocs. facelessuser/pymdown-extensions : this Python Markdown extension bundle. In order to build and preview the documents, just run the command below from the root of the project and you should be able to view the documents at localhost:8000 in your browser. After that, you should be able to update the documents and have your browser preview update live. mkdocs serve Spell Checking Documents \ue157 Spell checking is performed via facelessuser/pyspelling . During validation we build the docs and spell check various files in the project. Aspell must be installed and in the path. Currently this project uses one of the more recent versions of Aspell. It is not expected that everyone will install and run Aspell locally, but it will be run in CI tests for pull requests. In order to perform the spell check locally, it is expected you are setup to build the documents, and that you have Aspell installed in your system path (if needed you can use the --binary option to point to the location of your Aspell binary). It is also expected that you have the en dictionary installed as well. To initiate the spell check, run the following command from the root of the project. You will need to make sure the documents are built first: mkdocs build --clean And then run the spell checker. pyspelling It should print out the files with the misspelled words if any are found. If you find it prints words that are not misspelled, you can add them in docs/src/dictionary/en-custom.text . Validation Tests \ue157 In order to preserve good code health, a test suite has been put together with pytest ( pytest-dev/pytest ). To run these tests, you can use the following command: py.test Running Validation With Tox \ue157 Tox ( tox-dev/tox ) is a great way to run the validation tests, spelling checks, and linting in virtual environments so as not to mess with your current working environment. Tox will use the specified Python version for the given environment and create a virtual environment and install all the needed requirements (minus Aspell). You could also setup your own virtual environments with the Virtualenv module without Tox, and manually do the same. First, you need to have Tox installed: pip install tox By running Tox, it will walk through all the environments and create them (assuming you have all the python versions on your machine) and run the related tests. See tox.ini to learn more. tox If you don't have all the Python versions needed to test all the environments, those entries will fail. To run the tests for specific versions of Python, you specify the environment with -e PXY where X is the major version and Y is the minor version. tox -e py37 To target linting: tox -e lint To select spell checking and document building: tox -e documents Code Coverage \ue157 When running the validation tests through Tox, it is setup to track code coverage via the Coverage ( ned/coveragepy ) module. Coverage is run on each pyxx environment. If you've made changes to the code, you can clear the old coverage data: coverage erase Then run each unit test environment to generate coverage data. All the data from each run is merged together. HTML is output for each file in .tox/pyXX/tmp . You can use these to see areas that are not covered/exercised yet with testing. You can checkout tox.ini to see how this is accomplished. Code Documentation \ue157 The Soup Sieve module is laid out in the following structure: soupseive \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 __meta__.py \u251c\u2500\u2500 css_match.py \u251c\u2500\u2500 css_parser.py \u251c\u2500\u2500 css_types.py \u2514\u2500\u2500 util.py File Description __init__.py Contains the API for the user. __meta__.py Contains package meta data like version. css_match.py Contains the logic for matching tags with a CSS selector. css_parser.py Contains the CSS selector parser. css_types.py Contains the CSS types for the compiled CSS patterns. util.py Contains miscellaneous helper functions, classes, and constants. Compiled CSS Selector Structure \ue157 When a CSS selector string is given to Soup Sieve, it is run through the CSSParser class. CSSParser will return a SelectorList class. This class is sent to the SoupSieve class as a parameter along with things like namespace and flags . One of the most important things to understand when contributing is the structure of the SelectorList class. A SelectorList represents a list of compound selectors. So if you had the selector div > p , you would get a SelectorList object containing one Selector object. If you had div , p , you would get a SelectorList with two Selector objects as this is a selector list of two compound selectors. A compound selector gets parsed into pieces. Each part of a specific compound selector is usually assigned to an attribute in a single Selector object. The attributes of the Selector object may be as simple as a boolean or a string, but they can also be a tuple of more SelectorList objects. In the case of * : not ( p , div ) , * will be a SelectorList with one Selector . The : not ( p , div ) selector list will be a tuple containing one SelectorList of two Selectors (one for p and one for div ) under the selectors attribute of the * Selector . In short, Selectors are always contained within a SelectorList , and a compound selector is a single Selector object that may chain other SelectorLists objects depending on the complexity of the compound selector. If you provide a selector list, then you will get multiple Selector objects (one for each compound selector in the list) which in turn may chain other Selector objects. SelectorList \ue157 class SelectorList : \"\"\"Selector list.\"\"\" def __init__ ( self , selectors = tuple (), is_not = False ): \"\"\"Initialize.\"\"\" Attribute Description selectors A list of Selector objects. is_not The selectors in the selector list are from a :not() . is_html The selectors in the selector list are HTML specific. Selector \ue157 class Selector : \"\"\"Selector.\"\"\" def __init__ ( self , tag , ids , classes , attributes , nth , selectors , relation , rel_type , contains , lang , flags ): \"\"\"Initialize.\"\"\" Flags Description SEL_EMPTY The current compound selector contained an :empty pseudo-class. SEL_ROOT The current compound selector contains :root . SEL_DEFAULT The compound selector has a :default pattern and requires additional logic to determine if it is the first submit button in a form. SEL_INDETERMINATE The compound selector has a :indeterminate pattern and requires additional logic to ensure a radio element and all of the radio elements with the same name under a form are not set. Attribute Description tag Contains a single SelectorTag object, or None . id Contains a tuple of ids to match. Usually if multiple conflicting ids are present, it simply won't match a tag, but it allows multiple to handle the syntax tag#1#2 even if it is invalid. classes Contains a tuple of class names to match. attributes Contains a tuple of attributes. Each attribute is represented as a SelectorAttribute . nth Contains a tuple containing nth selectors, each selector being represented as a SelectorNth . nth selectors contain things like :first-child , :only-child , : nth-child () , : nth-of-type () , etc. selectors Contains a tuple of SelectorList objects for each pseudo-class selector part of the compound selector: : is () , : not () , : has () , etc. relation This will contain a SelectorList object with one Selector object, which could in turn chain an additional relation depending on the complexity of the compound selector. For instance, div > p + a would be a Selector for a that contains a relation for p (another SelectorList object) which also contains a relation of div . When matching, we would match that the tag is a , and then walk its relation chain verifying that they all match. In this case, the relation chain would be a direct, previous sibling of p , which has a direct parent of div . A :has() pseudo-class would walk this in the opposite order. div:has(> p + a) would verify div , and then check for a child of p with a sibling of a . rel_type rel_type is attached to relational selectors. In the case of div > p + a , the relational selectors of div and p would get a relational type of > and + respectively. :has() relational rel_type are preceded with : to signify a forward looking relation. contains Contains a tuple of strings of content to match in an element. lang Contains a tuple of SelectorLang objects. flags Selector flags that used to signal a type of selector is present. NullSelector \ue157 class NullSelector : \"\"\"Null Selector.\"\"\" def __init__ ( self ): \"\"\"Initialize.\"\"\" The null selector is like Selector , but it matches nothing. SelectorTag \ue157 class SelectorTag : \"\"\"Selector tag.\"\"\" def __init__ ( self , name , prefix ): \"\"\"Initialize.\"\"\" Attribute Description name name contains the tag name to match. prefix prefix contains the namespace prefix to match. prefix can also be None . SelectorAttribute \ue157 class SelectorAttribute : \"\"\"Selector attribute rule.\"\"\" def __init__ ( self , attribute , prefix , pattern , xml_type_pattern ): \"\"\"Initialize.\"\"\" Attribute Description attribute Contains the attribute name to match. prefix Contains the attribute namespace prefix to match if any. pattern Contains a re regular expression object that matches the desired attribute value. xml_type_pattern As the default type pattern is case insensitive, when the attribute value is type and a case sensitivity has not been explicitly defined, a secondary case sensitive type pattern is compiled for use with XML documents when detected. SelectorNth \ue157 class SelectorNth : \"\"\"Selector nth type.\"\"\" def __init__ ( self , a , n , b , of_type , last , selectors ): \"\"\"Initialize.\"\"\" Attribute Description a The a value in the formula an+b specifying an index. n True if the provided formula has included a literal n which signifies the formula is not a static index. b The b value in the formula an+b . type True if the nth pseudo-class is an *-of-type variant. last True if the nth pseudo-class is a *last* variant. selectors A SelectorList object representing the of S portion of :nth-chld(an+b [of S]?) . SelectorLang \ue157 class SelectorLang : \"\"\"Selector language rules.\"\"\" def __init__ ( self , languages ): \"\"\"Initialize.\"\"\" Attribute Description languages A list of regular expression objects that match a language pattern.","title":"Development"},{"location":"about/development/#development","text":"","title":"Development"},{"location":"about/development/#project-layout","text":"There are a number of files for build, test, and continuous integration in the root of the project, but in general, the project is broken up like so. \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 dictionary \u2502 \u2514\u2500\u2500 markdown \u251c\u2500\u2500 soupsieve \u251c\u2500\u2500 requirements \u2514\u2500\u2500 tests Directory Description docs/src/dictionary Contains the spell check wordlist(s) for the project. docs/src/markdown Contains the content for the documentation. soupsieve Contains the source code for the project. requirements Contains files with lists of dependencies that are required for the project, and required for continuous integration. tests Contains unit test files.","title":"Project Layout"},{"location":"about/development/#coding-standards","text":"When writing code, the code should roughly conform to PEP8 and PEP257 suggestions. The project utilizes the Flake8 linter (with some additional plugins) to ensure code conforms (give or take some of the rules). When in doubt, follow the formatting hints of existing code when adding files or modifying existing files. Listed below are the modules used: pycqa/flake8 pycqa/flake8-docstrings pycqa/pep8-naming ebeweber/flake8-mutable gforcada/flake8-builtins Usually this can be automated with Tox (assuming it is installed): tox -e lint .","title":"Coding Standards"},{"location":"about/development/#building-and-editing-documents","text":"Documents are in Markdown (with with some additional syntax provided by extensions) and are converted to HTML via Python Markdown. If you would like to build and preview the documentation, you must have these packages installed: Python-Markdown/markdown : the Markdown parser. mkdocs/mkdocs : the document site generator. squidfunk/mkdocs-material : a material theme for MkDocs. facelessuser/pymdown-extensions : this Python Markdown extension bundle. In order to build and preview the documents, just run the command below from the root of the project and you should be able to view the documents at localhost:8000 in your browser. After that, you should be able to update the documents and have your browser preview update live. mkdocs serve","title":"Building and Editing Documents"},{"location":"about/development/#spell-checking-documents","text":"Spell checking is performed via facelessuser/pyspelling . During validation we build the docs and spell check various files in the project. Aspell must be installed and in the path. Currently this project uses one of the more recent versions of Aspell. It is not expected that everyone will install and run Aspell locally, but it will be run in CI tests for pull requests. In order to perform the spell check locally, it is expected you are setup to build the documents, and that you have Aspell installed in your system path (if needed you can use the --binary option to point to the location of your Aspell binary). It is also expected that you have the en dictionary installed as well. To initiate the spell check, run the following command from the root of the project. You will need to make sure the documents are built first: mkdocs build --clean And then run the spell checker. pyspelling It should print out the files with the misspelled words if any are found. If you find it prints words that are not misspelled, you can add them in docs/src/dictionary/en-custom.text .","title":"Spell Checking Documents"},{"location":"about/development/#validation-tests","text":"In order to preserve good code health, a test suite has been put together with pytest ( pytest-dev/pytest ). To run these tests, you can use the following command: py.test","title":"Validation Tests"},{"location":"about/development/#running-validation-with-tox","text":"Tox ( tox-dev/tox ) is a great way to run the validation tests, spelling checks, and linting in virtual environments so as not to mess with your current working environment. Tox will use the specified Python version for the given environment and create a virtual environment and install all the needed requirements (minus Aspell). You could also setup your own virtual environments with the Virtualenv module without Tox, and manually do the same. First, you need to have Tox installed: pip install tox By running Tox, it will walk through all the environments and create them (assuming you have all the python versions on your machine) and run the related tests. See tox.ini to learn more. tox If you don't have all the Python versions needed to test all the environments, those entries will fail. To run the tests for specific versions of Python, you specify the environment with -e PXY where X is the major version and Y is the minor version. tox -e py37 To target linting: tox -e lint To select spell checking and document building: tox -e documents","title":"Running Validation With Tox"},{"location":"about/development/#code-coverage","text":"When running the validation tests through Tox, it is setup to track code coverage via the Coverage ( ned/coveragepy ) module. Coverage is run on each pyxx environment. If you've made changes to the code, you can clear the old coverage data: coverage erase Then run each unit test environment to generate coverage data. All the data from each run is merged together. HTML is output for each file in .tox/pyXX/tmp . You can use these to see areas that are not covered/exercised yet with testing. You can checkout tox.ini to see how this is accomplished.","title":"Code Coverage"},{"location":"about/development/#code-documentation","text":"The Soup Sieve module is laid out in the following structure: soupseive \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 __meta__.py \u251c\u2500\u2500 css_match.py \u251c\u2500\u2500 css_parser.py \u251c\u2500\u2500 css_types.py \u2514\u2500\u2500 util.py File Description __init__.py Contains the API for the user. __meta__.py Contains package meta data like version. css_match.py Contains the logic for matching tags with a CSS selector. css_parser.py Contains the CSS selector parser. css_types.py Contains the CSS types for the compiled CSS patterns. util.py Contains miscellaneous helper functions, classes, and constants.","title":"Code Documentation"},{"location":"about/development/#compiled-css-selector-structure","text":"When a CSS selector string is given to Soup Sieve, it is run through the CSSParser class. CSSParser will return a SelectorList class. This class is sent to the SoupSieve class as a parameter along with things like namespace and flags . One of the most important things to understand when contributing is the structure of the SelectorList class. A SelectorList represents a list of compound selectors. So if you had the selector div > p , you would get a SelectorList object containing one Selector object. If you had div , p , you would get a SelectorList with two Selector objects as this is a selector list of two compound selectors. A compound selector gets parsed into pieces. Each part of a specific compound selector is usually assigned to an attribute in a single Selector object. The attributes of the Selector object may be as simple as a boolean or a string, but they can also be a tuple of more SelectorList objects. In the case of * : not ( p , div ) , * will be a SelectorList with one Selector . The : not ( p , div ) selector list will be a tuple containing one SelectorList of two Selectors (one for p and one for div ) under the selectors attribute of the * Selector . In short, Selectors are always contained within a SelectorList , and a compound selector is a single Selector object that may chain other SelectorLists objects depending on the complexity of the compound selector. If you provide a selector list, then you will get multiple Selector objects (one for each compound selector in the list) which in turn may chain other Selector objects.","title":"Compiled CSS Selector Structure"},{"location":"about/development/#selectorlist","text":"class SelectorList : \"\"\"Selector list.\"\"\" def __init__ ( self , selectors = tuple (), is_not = False ): \"\"\"Initialize.\"\"\" Attribute Description selectors A list of Selector objects. is_not The selectors in the selector list are from a :not() . is_html The selectors in the selector list are HTML specific.","title":"SelectorList"},{"location":"about/development/#selector","text":"class Selector : \"\"\"Selector.\"\"\" def __init__ ( self , tag , ids , classes , attributes , nth , selectors , relation , rel_type , contains , lang , flags ): \"\"\"Initialize.\"\"\" Flags Description SEL_EMPTY The current compound selector contained an :empty pseudo-class. SEL_ROOT The current compound selector contains :root . SEL_DEFAULT The compound selector has a :default pattern and requires additional logic to determine if it is the first submit button in a form. SEL_INDETERMINATE The compound selector has a :indeterminate pattern and requires additional logic to ensure a radio element and all of the radio elements with the same name under a form are not set. Attribute Description tag Contains a single SelectorTag object, or None . id Contains a tuple of ids to match. Usually if multiple conflicting ids are present, it simply won't match a tag, but it allows multiple to handle the syntax tag#1#2 even if it is invalid. classes Contains a tuple of class names to match. attributes Contains a tuple of attributes. Each attribute is represented as a SelectorAttribute . nth Contains a tuple containing nth selectors, each selector being represented as a SelectorNth . nth selectors contain things like :first-child , :only-child , : nth-child () , : nth-of-type () , etc. selectors Contains a tuple of SelectorList objects for each pseudo-class selector part of the compound selector: : is () , : not () , : has () , etc. relation This will contain a SelectorList object with one Selector object, which could in turn chain an additional relation depending on the complexity of the compound selector. For instance, div > p + a would be a Selector for a that contains a relation for p (another SelectorList object) which also contains a relation of div . When matching, we would match that the tag is a , and then walk its relation chain verifying that they all match. In this case, the relation chain would be a direct, previous sibling of p , which has a direct parent of div . A :has() pseudo-class would walk this in the opposite order. div:has(> p + a) would verify div , and then check for a child of p with a sibling of a . rel_type rel_type is attached to relational selectors. In the case of div > p + a , the relational selectors of div and p would get a relational type of > and + respectively. :has() relational rel_type are preceded with : to signify a forward looking relation. contains Contains a tuple of strings of content to match in an element. lang Contains a tuple of SelectorLang objects. flags Selector flags that used to signal a type of selector is present.","title":"Selector"},{"location":"about/development/#nullselector","text":"class NullSelector : \"\"\"Null Selector.\"\"\" def __init__ ( self ): \"\"\"Initialize.\"\"\" The null selector is like Selector , but it matches nothing.","title":"NullSelector"},{"location":"about/development/#selectortag","text":"class SelectorTag : \"\"\"Selector tag.\"\"\" def __init__ ( self , name , prefix ): \"\"\"Initialize.\"\"\" Attribute Description name name contains the tag name to match. prefix prefix contains the namespace prefix to match. prefix can also be None .","title":"SelectorTag"},{"location":"about/development/#selectorattribute","text":"class SelectorAttribute : \"\"\"Selector attribute rule.\"\"\" def __init__ ( self , attribute , prefix , pattern , xml_type_pattern ): \"\"\"Initialize.\"\"\" Attribute Description attribute Contains the attribute name to match. prefix Contains the attribute namespace prefix to match if any. pattern Contains a re regular expression object that matches the desired attribute value. xml_type_pattern As the default type pattern is case insensitive, when the attribute value is type and a case sensitivity has not been explicitly defined, a secondary case sensitive type pattern is compiled for use with XML documents when detected.","title":"SelectorAttribute"},{"location":"about/development/#selectornth","text":"class SelectorNth : \"\"\"Selector nth type.\"\"\" def __init__ ( self , a , n , b , of_type , last , selectors ): \"\"\"Initialize.\"\"\" Attribute Description a The a value in the formula an+b specifying an index. n True if the provided formula has included a literal n which signifies the formula is not a static index. b The b value in the formula an+b . type True if the nth pseudo-class is an *-of-type variant. last True if the nth pseudo-class is a *last* variant. selectors A SelectorList object representing the of S portion of :nth-chld(an+b [of S]?) .","title":"SelectorNth"},{"location":"about/development/#selectorlang","text":"class SelectorLang : \"\"\"Selector language rules.\"\"\" def __init__ ( self , languages ): \"\"\"Initialize.\"\"\" Attribute Description languages A list of regular expression objects that match a language pattern.","title":"SelectorLang"},{"location":"about/license/","text":"License \ue157 MIT License Copyright \u00a9 2018 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"MIT License Copyright \u00a9 2018 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}